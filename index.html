<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Blockscape — simple landscape-style tiles</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --tile: 104px;
      --gap: 10px;
      --radius: 10px;
      --fg: #222;
      --muted: #666;
      --bg: #fff;
      --line: #e5e7eb;
      --dep: #1d4ed8;
      --revdep: #b91c1c;
      --reused: #b45309;
      --external: #6b7280;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial;
    }

    header {
      position: sticky;
      top: 0;
      background: rgba(255, 255, 255, .9);
      backdrop-filter: blur(6px);
      border-bottom: 1px solid var(--line);
      padding: .5rem .75rem;
      display: flex;
      align-items: center;
      gap: .5rem;
      z-index: 10;
      flex-wrap: wrap;
    }

    header h1 {
      font-size: 14px;
      margin: 0 .5rem 0 0;
      font-weight: 600;
      letter-spacing: .2px;
    }

    input[type="text"] {
      height: 32px;
      padding: 0 .5rem;
      border: 1px solid var(--line);
      border-radius: 999px;
      width: 220px;
    }

    select {
      height: 32px;
      padding: 0 .5rem;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      max-width: 320px;
    }

    button,
    label.pill {
      height: 32px;
      padding: 0 .75rem;
      background: #f9fafb;
      border: 1px solid var(--line);
      border-radius: 999px;
      cursor: pointer;
      white-space: nowrap;
    }

    .pill input[type=file] {
      display: none;
    }

    main {
      padding: .75rem;
    }

    .category {
      margin: .75rem 0 1.25rem 0;
    }

    .cat-head {
      display: flex;
      align-items: center;
      gap: .5rem;
      margin-bottom: .4rem;
    }

    .cat-title {
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: .4px;
      color: #374151;
    }

    .grid {
      position: relative;
      display: grid;
      grid-auto-rows: var(--tile);
      grid-template-columns: repeat(auto-fill, minmax(var(--tile), 1fr));
      gap: var(--gap);
      padding: var(--gap) 0;
      border-top: 1px dashed #eaecef;
    }

    .tile {
      position: relative;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: var(--radius);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: .35rem;
      cursor: grab;
      transition: box-shadow .15s ease, transform .05s ease, border-color .15s ease;
    }

    .tile:hover {
      box-shadow: 0 2px 10px rgba(0, 0, 0, .06);
    }

    .tile:active {
      transform: translateY(1px);
    }

    .tile.dragging {
      opacity: 0.5;
      cursor: grabbing;
      transform: rotate(5deg);
    }

    .tile.drag-over {
      border-color: var(--dep);
      box-shadow: 0 0 0 2px var(--dep) inset;
    }

    .grid.drag-active {
      background: rgba(29, 78, 216, 0.05);
    }

    .logo {
      width: 44px;
      height: 44px;
      object-fit: contain;
      opacity: .95;
    }

    .name {
      font-size: 11px;
      text-align: center;
      line-height: 1.1;
      padding: 0 .35rem .25rem;
    }

    .badge {
      position: absolute;
      top: 6px;
      right: 6px;
      font-size: 10px;
      background: #fff7ed;
      color: var(--reused);
      border: 1px solid #fed7aa;
      border-radius: 999px;
      padding: .05rem .35rem;
      display: none;
    }

    .tile.reused .badge {
      display: inline-block;
    }

    .tile.external {
      border-style: dashed;
      border-color: #cbd5e1;
      color: #374151;
    }

    .tile.dep {
      box-shadow: 0 0 0 2px var(--dep) inset;
      border-color: var(--dep);
    }

    .tile.revdep {
      box-shadow: 0 0 0 2px var(--revdep) inset;
      border-color: var(--revdep);
    }

    .tile.selected {
      outline: 2px solid #111827;
      outline-offset: 1px;
    }

    .muted {
      color: var(--muted);
    }

    .svg-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .legend {
      margin-left: auto;
      font-size: 12px;
      color: #374151;
      display: flex;
      gap: .5rem;
      align-items: center;
    }

    .dot {
      width: .7rem;
      height: .7rem;
      border-radius: 50%;
      display: inline-block;
      border: 1px solid #999;
    }

    .ddep {
      background: #dbeafe;
      border-color: var(--dep);
    }

    .drev {
      background: #fee2e2;
      border-color: var(--revdep);
    }

    .dreused {
      background: #ffedd5;
      border-color: var(--reused);
    }

    .dext {
      background: #f3f4f6;
      border-color: var(--external);
    }

    .sr-only {
      position: absolute;
      left: -10000px;
    }
  </style>
</head>

<body>
  <header>
    <h1>Blockscape</h1>
    <a href="https://github.com/pwright/blockscape" target="_blank" style="display: inline-flex; align-items: center; text-decoration: none; margin-right: .5rem;" title="View on GitHub">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="color: var(--muted);">
        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
      </svg>
    </a>
    <input id="search" type="text" placeholder="Search…" />
    <input id="urlInput" type="text" placeholder="Load JSON from URL…" style="width: 200px;" />
    <button id="loadUrl">Load URL</button>
    <label class="pill">Add JSON files <input id="file" type="file" accept=".json,.txt" multiple /></label>

    <!-- NEW: model chooser + management -->
    <select id="modelSelect" title="Active model"></select>
    <button id="removeModel" title="Remove selected model">Remove</button>
    <button id="clear">Clear selection</button>

    <div class="legend">
      <span><span class="dot ddep"></span> enables</span>
      <span><span class="dot drev"></span> dependents</span>
      <span><span class="dot dreused"></span> reused</span>
      <span><span class="dot dext"></span> external</span>
    </div>
  </header>

  <details style="margin:.5rem .75rem;">
    <summary style="cursor:pointer;">Paste / edit JSON for the <b>active</b> model (schema below)</summary>
    <div class="muted" style="font-size:12px;margin:.25rem 0 .5rem 0">
      Schema: <code>{ categories:[{id, title, items:[{id,name,logo?,external?,color?,deps:[] }]}], links?:[{from,to}] }</code><br />
      You can paste multiple objects separated by <code>---</code> to append several models. A single object replaces only when you click “Replace active with JSON”.
    </div>
    <div style="display:flex;gap:.5rem;align-items:flex-start;">
      <textarea id="jsonBox"
        style="flex:1;height:160px;font-family:ui-monospace,Consolas,monospace;resize:vertical;"></textarea>
      <div style="display:flex;flex-direction:column;gap:.4rem;">
        <button id="appendFromBox">Append model(s)</button>
        <button id="replaceActive">Replace active with JSON</button>
      </div>
    </div>
  </details>

  <main id="app" aria-live="polite"></main>

  <template id="seed">
    {
      "abstract": "Blockscape is a tool for visualizing value chains and dependency relationships. It can be used to visualize the value chain of a project, a product, or a service. It can also be used to visualize the dependencies between different components of a project.<br>The tool enables users to understand dependencies, relationships, and value chains within a domain.<br>You can choose other data from the 'Seed Template' pulldown.<br>Or load data from a URL.<br>Select an item to see its dependencies.",
      "categories": [
        {
          "id": "communication",
          "title": "Communication Effects",
          "items": [
            {
              "id": "glance_comprehension",
              "name": "Glanceable Landscape",
              "deps": [
                "value_visibility_axis",
                "legend_minimal"
              ]
            },
            {
              "id": "component_values",
              "name": "Component Values",
              "deps": [
                "layout_engine",
                "model_components"
              ]
            },
            {
              "id": "review_alignment",
              "name": "Shared Understanding",
              "deps": [
                "glance_comprehension",
                "component_values"
              ]
            }
          ]
        },
        {
          "id": "inputs",
          "title": "Inputs",
          "items": [
            {
              "id": "domain_prompt",
              "name": "Domain Prompt",
              "deps": []
            },
            {
              "id": "domain_json",
              "name": "Domain JSON",
              "deps": []
            }
          ]
        },
        {
          "id": "modeling",
          "title": "Modeling",
          "items": [
            {
              "id": "model_components",
              "name": "Components and Categories",
              "deps": [
                "domain_json"
              ]
            },
            {
              "id": "model_dependencies",
              "name": "Dependencies",
              "deps": [
                "model_components"
              ]
            }
          ]
        },
        {
          "id": "rendering",
          "title": "Rendering",
          "items": [
            {
              "id": "layout_engine",
              "name": "Layout Engine",
              "deps": [
                "model_components",
                "model_dependencies"
              ]
            },
            {
              "id": "value_visibility_axis",
              "name": "Vertical Position = Visible Value",
              "deps": [
                "layout_engine"
              ]
            },
            {
              "id": "evolution_axis",
              "name": "Horizontal Evolution (Optional)",
              "deps": [
                "layout_engine"
              ]
            }
          ]
        },
        {
          "id": "outputs",
          "title": "Outputs",
          "items": [
            {
              "id": "guideframe",
              "name": "Video creation",
              "deps": [
 
              ]
            },
            {
              "id": "website",
              "name": "Website",
              "deps": [
                "layout_engine"
              ]
            }

          ]
        }
      ]
    }
  </template>


  <svg id="overlay" class="svg-layer"></svg>

  <script>
    console.log("[Blockscape] init");

    const jsonBox = document.getElementById('jsonBox');
    const app = document.getElementById('app');
    const overlay = document.getElementById('overlay');
    const modelSelect = document.getElementById('modelSelect');

    // Show the seed in the editor initially.
    jsonBox.value = document.getElementById('seed').innerHTML.trim();

    // ===== State =====
    /** @type {{id:string,title:string,data:any}[]} */
    let models = [];
    let activeIndex = -1;

    let model = null;           // parsed result of active model: { m, fwd, rev, reusedLocal, seen }
    let index = new Map();      // id -> {el, catId, rect}
    let selection = null;

    // ===== Utilities =====
    function uid() { return Math.random().toString(36).slice(2, 10); }

    // --- NEW: letter → color mapping and helpers ---
    // Letter → color mapping (tailwind-ish palette). G => green.
    const LETTER_COLOR_MAP = {
      A: '#ef4444', B: '#3b82f6', C: '#06b6d4', D: '#a855f7',
      E: '#f59e0b', F: '#f97316', G: '#22c55e', H: '#84cc16',
      I: '#10b981', J: '#14b8a6', K: '#0ea5e9', L: '#60a5fa',
      M: '#8b5cf6', N: '#d946ef', O: '#f43f5e', P: '#e11d48',
      Q: '#dc2626', R: '#f59e0b', S: '#eab308', T: '#a3e635',
      U: '#22d3ee', V: '#38bdf8', W: '#818cf8', X: '#a78bfa',
      Y: '#f472b6', Z: '#fb7185'
    };

    // Prefer explicit item.color (if present), else map by first letter.
    function getBadgeColor(text, explicit) {
      if (explicit && /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(explicit)) return explicit;
      const ch = (text || '?').charAt(0).toUpperCase();
      return LETTER_COLOR_MAP[ch] || '#9ca3af'; // fallback gray
    }

    // Compute readable letter color (black/white) against bg
    function idealTextColor(bgHex) {
      const hex = bgHex.replace('#', '');
      const expanded = hex.length === 3 ? hex.split('').map(c=>c+c).join('') : hex;
      const bigint = parseInt(expanded, 16);
      const r = (bigint >> 16) & 255, g = (bigint >> 8) & 255, b = bigint & 255;
      // luminance (sRGB)
      const L = 0.2126*Math.pow(r/255,2.2) + 0.7152*Math.pow(g/255,2.2) + 0.0722*Math.pow(b/255,2.2);
      return L > 0.35 ? '#111111' : '#ffffff';
    }

    function setActive(i) {
      if (i < 0 || i >= models.length) {
        console.warn("[Blockscape] setActive called with out-of-range index:", i);
        return;
      }
      activeIndex = i;
      console.log("[Blockscape] active model:", models[i].title, "(index", i + " )");
      updateModelSelect();
      loadActiveIntoEditor();
      rebuildFromActive();
    }

    function updateModelSelect() {
      modelSelect.innerHTML = "";
      models.forEach((m, i) => {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = `${i + 1}. ${m.title}`;
        modelSelect.appendChild(opt);
      });
      if (activeIndex >= 0) modelSelect.value = String(activeIndex);
    }

    function loadActiveIntoEditor() {
      if (activeIndex < 0) { jsonBox.value = ""; return; }
      jsonBox.value = JSON.stringify(models[activeIndex].data, null, 2);
    }

    function tryParseJson(txt) { try { return JSON.parse(txt); } catch { return null; } }

    // Accept 1) object, 2) array-of-objects, 3) '---' separated objects
    function normalizeToModelsFromText(txt, titleBase = "Pasted") {
      const trimmed = (txt || "").trim();
      if (!trimmed) return [];
      const parsed = tryParseJson(trimmed);
      if (parsed) return (Array.isArray(parsed) ? parsed : [parsed]).map((o, idx) => ({
        id: uid(),
        title: `${titleBase} #${idx + 1}`,
        data: o
      }));
      const parts = trimmed.split(/^\s*---\s*$/m).map(s => s.trim()).filter(Boolean);
      return parts.map((p, i) => ({
        id: uid(),
        title: `${titleBase} #${i + 1}`,
        data: JSON.parse(p)
      }));
    }

    function parse(mObj) {
      console.log("[Blockscape] parsing model; categories=", (mObj?.categories || []).length);
      const fwd = new Map();
      const rev = new Map();
      const seen = new Set();

      (mObj.categories || []).forEach(c => (c.items || []).forEach(it => {
        seen.add(it.id);
        const deps = new Set(it.deps || []);
        (mObj.links || []).forEach(l => { if (l.from === it.id) deps.add(l.to); });
        fwd.set(it.id, deps);
        deps.forEach(d => {
          if (!rev.has(d)) rev.set(d, new Set());
          rev.get(d).add(it.id);
        });
      }));

      const reusedLocal = new Set();
      rev.forEach((dependents, node) => { if ((dependents?.size || 0) >= 2) reusedLocal.add(node); });
      return { m: mObj, fwd, rev, reusedLocal, seen };
    }

    // --- MODIFIED: color-aware letter image ---
    function generateLetterImage(text, explicitColor) {
      console.log("[Blockscape] generateLetterImage for:", text);
      const canvas = document.createElement('canvas');
      const size = 44;
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext('2d');

      const letter = (text || '?').charAt(0).toUpperCase();
      const bg = getBadgeColor(text, explicitColor);
      const fg = idealTextColor(bg);

      // Circle
      ctx.fillStyle = bg;
      ctx.beginPath();
      ctx.arc(size/2, size/2, size/2 - 2, 0, 2*Math.PI);
      ctx.fill();

      // Subtle ring
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Letter
      ctx.fillStyle = fg;
      ctx.font = `bold ${size * 0.5}px system-ui, -apple-system, sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(letter, size/2, size/2);

      return canvas.toDataURL('image/png');
    }

    // ===== Render =====
    function render() {
      if (!model) return;
      console.log("[Blockscape] rendering categories=", model.m.categories.length);
      console.log("[Blockscape] model.m has abstract?", !!model.m.abstract, "- value:", model.m.abstract ? model.m.abstract.substring(0, 50) + "..." : "none");
      app.innerHTML = "";
      index.clear();

      overlay.setAttribute("width", window.innerWidth);
      overlay.setAttribute("height", window.innerHeight);

      // Add abstract if present
      if (model.m.abstract) {
        console.log("[Blockscape] Creating abstract div");
        const abstractDiv = document.createElement('div');
        abstractDiv.className = 'abstract';
        abstractDiv.style.cssText = 'font-size: 12px; color: var(--muted); margin: 0 0 1rem 0; line-height: 1.4; padding: 0.5rem 0.75rem; background: #f9fafb; border-radius: 6px; border-left: 3px solid var(--dep);';
        abstractDiv.innerHTML = model.m.abstract;
        app.appendChild(abstractDiv);
        console.log("[Blockscape] Abstract div appended to DOM");
      } else {
        console.log("[Blockscape] No abstract found in model.m");
      }

      model.m.categories.forEach(cat => {
        const section = document.createElement('section');
        section.className = 'category';
        section.dataset.cat = cat.id;

        const head = document.createElement('div');
        head.className = 'cat-head';
        head.innerHTML = `<div class="cat-title">${escapeHtml(cat.title || cat.id)}</div>
                          <div class="muted" style="font-size:12px">${(cat.items || []).length} items</div>`;
        section.appendChild(head);

        const grid = document.createElement('div');
        grid.className = 'grid';
        section.appendChild(grid);

        (cat.items || []).forEach(it => {
          const tile = document.createElement('div');
          tile.className = 'tile' + (it.external ? ' external' : '');
          tile.tabIndex = 0;
          tile.dataset.id = it.id;

          const img = document.createElement('img');
          img.className = 'logo';
          if (it.logo) {
            img.src = it.logo; img.alt = it.name || it.id;
          } else {
            img.alt = "";
            img.style.opacity = 1; // colored letter icon is the intended visual
            img.src = generateLetterImage(it.name || it.id, it.color); // supports optional per-item color
          }

          const nm = document.createElement('div');
          nm.className = 'name';
          nm.textContent = it.name || it.id;

          const badge = document.createElement('div');
          badge.className = 'badge';
          badge.textContent = 'reused';

          tile.appendChild(img);
          tile.appendChild(nm);
          tile.appendChild(badge);
          grid.appendChild(tile);

          index.set(it.id, { el: tile, catId: cat.id, rect: null });
        });

        app.appendChild(section);
      });

      model.reusedLocal.forEach(id => {
        const hit = index.get(id);
        if (hit) {
          hit.el.classList.add('reused');
          hit.el.querySelector('.badge').style.display = 'inline-block';
        }
      });

      wireEvents();
      reflowRects();
      drawLinks();
    }

    function wireEvents() {
      app.querySelectorAll('.tile').forEach(t => {
        t.addEventListener('click', () => {
          const id = t.dataset.id;
          console.log("[Blockscape] click", id);
          if (selection === id) { clearSelection(); return; }
          select(id);
        });
        t.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); t.click(); }
        });
        t.draggable = true;
        t.addEventListener('dragstart', handleDragStart);
        t.addEventListener('dragend', handleDragEnd);
      });

      app.querySelectorAll('.grid').forEach(grid => {
        grid.addEventListener('dragover', handleDragOver);
        grid.addEventListener('drop', handleDrop);
        grid.addEventListener('dragenter', handleDragEnter);
        grid.addEventListener('dragleave', handleDragLeave);
      });

      window.addEventListener('resize', () => { reflowRects(); drawLinks(); });
      document.getElementById('clear').onclick = () => clearSelection();
    }

    function reflowRects() { index.forEach((v) => { v.rect = v.el.getBoundingClientRect(); }); }

    function select(id) {
      selection = id;
      clearStyles();
      const deps = Array.from(model.fwd.get(id) || []);
      const revs = Array.from(model.rev.get(id) || []);
      console.log("[Blockscape] selecting id=", id, "deps=", deps, "revs=", revs);
      const sel = index.get(id); if (sel) sel.el.classList.add('selected');
      deps.forEach(d => { const hit = index.get(d); if (hit) hit.el.classList.add('dep'); });
      revs.forEach(r => { const hit = index.get(r); if (hit) hit.el.classList.add('revdep'); });
      drawLinks();
    }

    function clearSelection() { selection = null; clearStyles(); drawLinks(); }
    function clearStyles() { app.querySelectorAll('.tile').forEach(t => t.classList.remove('dep', 'revdep', 'selected')); }

    function drawLinks() {
      while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
      if (!selection) return;

      const fromRect = index.get(selection)?.rect;
      if (!fromRect) return;

      const toList = new Set([...(model.fwd.get(selection) || []), ...(model.rev.get(selection) || [])]);
      toList.forEach(to => {
        const target = index.get(to);
        if (!target || !target.rect) return;
        const a = center(fromRect);
        const b = center(target.rect);
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const c1x = (a.x + b.x) / 2, c1y = a.y;
        const c2x = (a.x + b.x) / 2, c2y = b.y;
        const isDep = (model.fwd.get(selection) || new Set()).has(to);
        path.setAttribute("d", `M ${a.x},${a.y} C ${c1x},${c1y} ${c2x},${c2y} ${b.x},${b.y}`);
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", isDep ? "var(--dep)" : "var(--revdep)");
        path.setAttribute("stroke-opacity", "0.45");
        path.setAttribute("stroke-width", "2");
        path.setAttribute("vector-effect", "non-scaling-stroke");
        overlay.appendChild(path);
      });
    }

    function center(r) { return { x: r.left + r.width / 2, y: r.top + r.height / 2 }; }
    function escapeHtml(s) { return s.replace(/[&<>"']/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" }[m])); }

    // ===== Drag and drop reorder (per model) =====
    let draggedItemId = null;
    let draggedCategoryId = null;

    function handleDragStart(e) {
      draggedItemId = e.target.dataset.id;
      draggedCategoryId = e.target.closest('.category').dataset.cat;

      e.target.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', JSON.stringify({
        itemId: draggedItemId,
        categoryId: draggedCategoryId
      }));

      const category = e.target.closest('.category');
      const grid = category.querySelector('.grid');
      grid.classList.add('drag-active');

      console.log("[Blockscape] drag start", draggedItemId, "from", draggedCategoryId);
    }

    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
      app.querySelectorAll('.grid').forEach(grid => grid.classList.remove('drag-active'));
      app.querySelectorAll('.tile').forEach(tile => tile.classList.remove('drag-over'));
      draggedItemId = null;
      draggedCategoryId = null;
    }

    function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }
    function handleDragEnter(e) {
      e.preventDefault();
      const grid = e.target.closest('.grid');
      if (grid) grid.classList.add('drag-active');
    }
    function handleDragLeave(e) {
      const grid = e.target.closest('.grid');
      if (grid && !grid.contains(e.relatedTarget)) grid.classList.remove('drag-active');
    }

    function handleDrop(e) {
      e.preventDefault();
      const targetGrid = e.target.closest('.grid');
      const targetCategory = targetGrid.closest('.category');
      const targetCategoryId = targetCategory.dataset.cat;

      if (!draggedItemId || !targetCategoryId) return;
      if (draggedCategoryId !== targetCategoryId) {
        console.log("[Blockscape] drop rejected - different category");
        return;
      }

      const tiles = Array.from(targetGrid.querySelectorAll('.tile'));
      const targetTile = tiles.find(tile => {
        const rect = tile.getBoundingClientRect();
        return e.clientY < rect.top + rect.height / 2;
      });

      reorderItem(draggedItemId, targetTile ? targetTile.dataset.id : null, targetCategoryId);
      render();
      console.log("[Blockscape] drop completed", draggedItemId, "in", targetCategoryId);
    }

    function reorderItem(itemId, targetItemId, categoryId) {
      if (activeIndex < 0) return;
      const mobj = models[activeIndex].data;
      const category = (mobj.categories || []).find(cat => cat.id === categoryId);
      if (!category) return;

      const itemIndex = (category.items || []).findIndex(item => item.id === itemId);
      if (itemIndex === -1) return;

      const [movedItem] = category.items.splice(itemIndex, 1);
      if (targetItemId) {
        const targetIndex = category.items.findIndex(item => item.id === targetItemId);
        if (targetIndex !== -1) category.items.splice(targetIndex, 0, movedItem);
        else category.items.push(movedItem);
      } else {
        category.items.push(movedItem);
      }
      // keep editor in sync
      loadActiveIntoEditor();
      rebuildFromActive();
    }

    // ===== Controls =====

    // Append models from textarea
    document.getElementById('appendFromBox').onclick = () => {
      try {
        const appended = normalizeToModelsFromText(jsonBox.value, "Pasted");
        if (!appended.length) { alert("No valid JSON found to append."); return; }
        console.log("[Blockscape] appending", appended.length, "model(s)");
        models.push(...appended);
        if (activeIndex === -1) setActive(0); else { updateModelSelect(); }
      } catch (e) {
        console.error("[Blockscape] append error:", e);
        alert("Append error (see console).");
      }
    };

    // Replace active model data with JSON from textarea
    document.getElementById('replaceActive').onclick = () => {
      if (activeIndex < 0) { alert("No active model selected."); return; }
      try {
        const obj = JSON.parse(jsonBox.value);
        models[activeIndex].data = obj;
        console.log("[Blockscape] replaced active model:", models[activeIndex].title);
        rebuildFromActive();
      } catch (e) {
        console.error("[Blockscape] replace error:", e);
        alert("JSON parse error (see console).");
      }
    };

    // Load files: each text may be single object, array, or --- separated
    document.getElementById('file').onchange = async (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;
      try {
        console.log("[Blockscape] reading", files.length, "file(s)");
        for (const f of files) {
          const txt = await f.text();
          const entries = normalizeToModelsFromText(txt, f.name.replace(/\.[^.]+$/, '') || "File");
          if (!entries.length) {
            console.warn("[Blockscape] no models in file:", f.name);
            continue;
          }
          // Ensure file-derived entries use filename as title base
          models.push(...entries.map((en, i) => ({ ...en, title: entries.length > 1 ? `${f.name} #${i + 1}` : f.name })));
        }
        if (activeIndex === -1 && models.length) setActive(0);
        else updateModelSelect();
      } catch (err) {
        console.error("[Blockscape] file load error:", err);
        alert("File load error (see console).");
      } finally {
        e.target.value = ""; // allow re-selecting the same files
      }
    };

    // Switch active model
    modelSelect.addEventListener('change', (e) => {
      const i = parseInt(e.target.value, 10);
      if (!Number.isInteger(i)) return;
      setActive(i);
    });

    // Remove selected model
    document.getElementById('removeModel').onclick = () => {
      if (activeIndex < 0) return;
      console.log("[Blockscape] removing model:", models[activeIndex].title);
      models.splice(activeIndex, 1);
      if (!models.length) {
        activeIndex = -1;
        model = null;
        app.innerHTML = "";
        overlay.innerHTML = "";
        jsonBox.value = "";
        updateModelSelect();
        return;
      }
      const next = Math.min(activeIndex, models.length - 1);
      setActive(next);
    };

    // Search filter
    document.getElementById('search').addEventListener('input', (e) => {
      const q = e.target.value.trim().toLowerCase();
      console.log("[Blockscape] search:", q);
      app.querySelectorAll('.tile').forEach(t => {
        const name = t.querySelector('.name').textContent.toLowerCase();
        t.style.opacity = (!q || name.includes(q)) ? 1 : .2;
      });
    });

    // Load from URL
    document.getElementById('loadUrl').addEventListener('click', async () => {
      const url = document.getElementById('urlInput').value.trim();
      if (!url) {
        alert("Please enter a URL");
        return;
      }
      await loadFromUrl(url);
      document.getElementById('urlInput').value = ''; // Clear input after successful load
    });

    // Allow Enter key in URL input
    document.getElementById('urlInput').addEventListener('keydown', async (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.getElementById('loadUrl').click();
      }
    });

    // Helpers
    function rebuildFromActive() {
      if (activeIndex < 0) return;
      try {
        const parsed = parse(models[activeIndex].data);
        model = parsed;
        render();
      } catch (e) {
        console.error("[Blockscape] rebuild error (active model likely malformed):", e);
        alert("Active model parse/render error (see console).");
      }
    }

    // Load JSON files from same directory (for static hosting)
    async function loadJsonFiles() {
      const jsonFiles = ['NFR.json', 'ISO-IEC-25010.json', 'SEII-QAW.json'];
      
      for (const filename of jsonFiles) {
        try {
          const response = await fetch(filename);
          if (response.ok) {
            const data = await response.json();
            models.push({ 
              id: uid(), 
              title: filename.replace('.json', ''), 
              data: data 
            });
            console.log("[Blockscape] loaded", filename);
          }
        } catch (error) {
          console.log("[Blockscape] could not load", filename, "- this is normal for file:// protocol");
        }
      }
    }

    // Load JSON from custom URL
    async function loadFromUrl(url) {
      try {
        console.log("[Blockscape] loading from URL:", url);
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        const filename = url.split('/').pop().replace('.json', '') || 'URL Model';
        models.push({ 
          id: uid(), 
          title: filename, 
          data: data 
        });
        console.log("[Blockscape] loaded from URL:", filename);
        updateModelSelect();
        if (activeIndex === -1) setActive(0);
        return true;
      } catch (error) {
        console.error("[Blockscape] URL load error:", error);
        alert(`Failed to load JSON from URL: ${error.message}`);
        return false;
      }
    }

    // Bootstrap with seed template
    (async function bootstrap() {
      const seedObj = JSON.parse(document.getElementById('seed').innerHTML.trim());
      
      models.push({ id: uid(), title: "Seed Template", data: seedObj });
      
      // Try to load JSON files from same directory
      await loadJsonFiles();
      
      setActive(0);
    })();
  </script>
</body>

</html>
