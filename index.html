<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Blockscape — simple landscape-style tiles</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <style>
    :root {
      color-scheme: light;
      --space-2xs: 0.2rem;
      --space-xs: 0.35rem;
      --space-sm: 0.5rem;
      --space-md: 0.75rem;
      --space-lg: 1.25rem;
      --space-xl: 2rem;
      --space-2xl: 3rem;

      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 16px;

      --font-text: "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;
      --font-mono: "JetBrains Mono", "Fira Code", monospace;
      --font-size-xs: 0.75rem;
      --font-size-sm: 0.875rem;
      --font-size-md: 1rem;
      --font-size-lg: 1.2rem;
      --font-weight-regular: 400;
      --font-weight-medium: 500;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;

      --color-text: #1f2937;
      --color-muted: #6b7280;
      --color-border: #d8dde8;
      --color-border-strong: #c3cad7;
      --color-surface: #ffffff;
      --color-surface-muted: #f4f6fb;
      --color-surface-subtle: #eef2f8;
      --color-shadow: 0 18px 36px -22px rgba(15, 23, 42, 0.45);

      --color-primary: #2563eb;
      --color-primary-soft: #e3edff;
      --color-danger: #dc2626;
      --color-danger-soft: #fde4e2;
      --color-warning: #f97316;
      --color-warning-soft: #ffe8d6;
      --color-accent: #0ea5e9;
      --color-external: #94a3b8;

      --transition: 160ms ease;

      --blockscape-tile: 6.5rem;
      --blockscape-gap: var(--space-md);
      --blockscape-radius: var(--radius-lg);
      --blockscape-foreground: var(--color-text);
      --blockscape-muted: var(--color-muted);
      --blockscape-border: var(--color-border);
      --blockscape-surface: var(--color-surface);
      --blockscape-surface-alt: var(--color-surface-muted);
      --blockscape-dep: var(--color-primary);
      --blockscape-revdep: #ef4444;
      --blockscape-reused: var(--color-warning);
      --blockscape-external: var(--color-external);
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: var(--color-surface-subtle);
      color: var(--color-text);
      font-family: var(--font-text);
      -webkit-font-smoothing: antialiased;
    }

    a {
      color: inherit;
    }

    .pf-v5-c-page {
      min-height: 100%;
      display: flex;
      flex-direction: column;
    }

    .pf-v5-c-page__header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: var(--color-surface);
      box-shadow: 0 1px 0 var(--color-border);
    }

    .blockscape-masthead {
      border-bottom: none;
    }

    .blockscape-toolbar {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: var(--space-md);
      padding: var(--space-sm) var(--space-lg);
      width: min(1180px, 100%);
      margin: 0 auto;
    }

    .blockscape-brand {
      display: inline-flex;
      align-items: center;
      gap: var(--space-sm);
      font-weight: var(--font-weight-bold);
      font-size: var(--font-size-lg);
      letter-spacing: 0.04em;
      text-transform: uppercase;
      margin-right: var(--space-sm);
    }

    .blockscape-brand h1 {
      font: inherit;
      margin: 0;
    }

    .blockscape-brand__logo {
      display: block;
      height: 52px;
      width: auto;
      max-width: 320px;
    }

    .blockscape-toolbar__controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: var(--space-sm);
      flex: 1 1 auto;
      min-width: 280px;
    }

    .blockscape-toolbar__controls .pf-v5-c-form-control {
      min-width: 11rem;
    }

    .blockscape-toolbar__controls .pf-v5-c-form-control.is-url {
      min-width: 14rem;
    }

    .blockscape-file {
      position: relative;
    }

    .blockscape-file input[type="file"] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .pf-v5-c-button {
      appearance: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-xs);
      border-radius: 999px;
      border: 1px solid transparent;
      padding: 0.4rem 0.95rem;
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-semibold);
      line-height: 1;
      cursor: pointer;
      transition: background var(--transition), border-color var(--transition), color var(--transition), box-shadow var(--transition);
      background: transparent;
      color: var(--blockscape-foreground);
    }

    .pf-v5-c-button:hover {
      box-shadow: 0 8px 18px -12px rgba(15, 23, 42, 0.4);
    }

    .pf-v5-c-button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.25);
    }

    .pf-v5-c-button.pf-m-primary {
      background: var(--color-primary);
      border-color: var(--color-primary);
      color: #fff;
    }

    .pf-v5-c-button.pf-m-primary:hover {
      background: #1d4fd7;
      border-color: #1d4fd7;
    }

    .pf-v5-c-button.pf-m-secondary {
      background: var(--color-surface-muted);
      border-color: var(--color-border-strong);
      color: var(--blockscape-foreground);
    }

    .pf-v5-c-button.pf-m-secondary:hover {
      background: #e5e9f4;
    }

    .pf-v5-c-button.pf-m-tertiary {
      background: transparent;
      border-color: var(--color-border);
      color: var(--color-muted);
    }

    .pf-v5-c-button.pf-m-tertiary:hover {
      color: var(--blockscape-foreground);
      border-color: var(--color-border-strong);
      background: var(--color-surface-muted);
    }

    .pf-v5-c-button.pf-m-plain {
      border: none;
      padding: 0.35rem;
      color: var(--color-muted);
      border-radius: 50%;
    }

    .pf-v5-c-button.pf-m-plain:hover {
      background: var(--color-surface-muted);
      color: var(--blockscape-foreground);
      box-shadow: none;
    }

    .pf-v5-c-form-control {
      height: 2.5rem;
      padding: 0 0.85rem;
      border-radius: 999px;
      border: 1px solid var(--color-border);
      background: var(--color-surface);
      font-family: inherit;
      font-size: var(--font-size-sm);
      color: inherit;
      transition: border-color var(--transition), box-shadow var(--transition);
    }

    .pf-v5-c-form-control::placeholder {
      color: var(--color-muted);
      opacity: 0.75;
    }

    .pf-v5-c-form-control:focus-visible {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
    }

    .blockscape-legend {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: var(--space-md);
      font-size: var(--font-size-xs);
      color: var(--blockscape-muted);
      font-weight: var(--font-weight-medium);
      flex-wrap: wrap;
    }

    .legend-entry {
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
      white-space: nowrap;
    }

    .legend-dot {
      width: 0.65rem;
      height: 0.65rem;
      border-radius: 50%;
      border: 1px solid var(--blockscape-border);
    }

    .legend-dot--dep {
      background: var(--color-primary-soft);
      border-color: var(--blockscape-dep);
    }

    .legend-dot--revdep {
      background: var(--color-danger-soft);
      border-color: var(--blockscape-revdep);
    }

    .legend-dot--reused {
      background: var(--color-warning-soft);
      border-color: var(--blockscape-reused);
    }

    .legend-dot--external {
      background: #edf1f7;
      border-color: var(--blockscape-external);
    }

    .pf-v5-c-page__main {
      flex: 1 1 auto;
    }

    .blockscape-content {
      display: flex;
      gap: var(--space-lg);
      width: min(1180px, calc(100% - 2 * var(--space-lg)));
      margin: 0 auto;
      padding: var(--space-lg) 0 var(--space-xl);
      align-items: flex-start;
    }

    .blockscape-sidebar {
      flex: 0 0 240px;
      background: var(--blockscape-surface);
      border: 1px solid var(--blockscape-border);
      border-radius: var(--radius-md);
      padding: var(--space-md);
      box-shadow: var(--color-shadow);
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .sidebar-heading {
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--blockscape-muted);
    }

    .model-nav-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }

    .model-nav-list li {
      margin: 0;
      padding: 0;
    }

    .model-nav-button {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      text-align: left;
      gap: var(--space-2xs);
      border: 1px solid transparent;
      border-radius: var(--radius-sm);
      background: transparent;
      color: var(--color-text);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      padding: var(--space-sm);
      cursor: pointer;
      transition: background var(--transition), border-color var(--transition), color var(--transition);
    }

    .model-nav-button:hover,
    .model-nav-button:focus-visible {
      outline: none;
      border-color: var(--color-border);
      background: var(--color-surface-muted);
    }

    .model-nav-button.is-active {
      border-color: var(--color-primary);
      background: var(--color-primary-soft);
      color: var(--color-primary);
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.1);
    }

    .model-nav-label {
      font-weight: var(--font-weight-semibold);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: var(--space-2xs);
    }

    .model-nav-title {
      font-size: var(--font-size-sm);
    }

    .model-nav-id {
      font-size: var(--font-size-xs);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--blockscape-muted);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-sm);
      padding: 0 var(--space-2xs);
      background: var(--color-surface-muted);
    }

    .model-nav-meta {
      font-size: var(--font-size-xs);
      color: var(--blockscape-muted);
    }

    .model-nav-empty {
      font-size: var(--font-size-xs);
      color: var(--blockscape-muted);
    }

    .model-actions {
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }

    .model-actions .pf-v5-c-button {
      width: 100%;
    }

    .blockscape-main {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
    }

    .blockscape-json-panel,
    .blockscape-main-section {
      width: 100%;
      margin: 0;
    }

    .blockscape-json-panel {
      padding: 0;
      border: none;
      background: transparent;
      box-shadow: none;
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
    }

    .blockscape-json-panel__title {
      font-weight: var(--font-weight-semibold);
      font-size: var(--font-size-sm);
      margin: 0;
    }

    .blockscape-json-panel .muted {
      font-size: var(--font-size-xs);
      margin: 0;
      line-height: 1.4;
    }

    .blockscape-json-controls {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-md);
      align-items: flex-start;
    }

    .blockscape-json-controls textarea {
      flex: 1 1 22rem;
      min-height: 12rem;
      font-family: var(--font-mono);
      font-size: var(--font-size-sm);
      border-radius: var(--radius-md);
      border: 1px solid var(--color-border);
      padding: var(--space-sm) var(--space-md);
      background: var(--color-surface-muted);
      color: var(--blockscape-foreground);
      resize: vertical;
      transition: border-color var(--transition), box-shadow var(--transition);
    }

    .blockscape-json-controls textarea:focus-visible {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
      background: var(--color-surface);
    }

    .blockscape-json-actions {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      min-width: 12rem;
    }

    .blockscape-main-section {
      padding: 0 var(--space-lg) var(--space-xl);
    }

    .blockscape-model-meta {
      margin-bottom: var(--space-md);
      display: flex;
      flex-direction: column;
      gap: var(--space-2xs);
    }

    .blockscape-model-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text);
    }

    .blockscape-model-id {
      font-size: var(--font-size-xs);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--blockscape-muted);
    }

    .blockscape-tabs {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      margin-top: var(--space-md);
    }

    .blockscape-tablist {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2xs);
      border-bottom: 1px solid var(--color-border);
    }

    .blockscape-tab {
      appearance: none;
      border: 1px solid transparent;
      border-bottom: none;
      border-radius: var(--radius-md) var(--radius-md) 0 0;
      background: transparent;
      padding: var(--space-sm) var(--space-md);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-semibold);
      color: var(--blockscape-muted);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: var(--space-2xs);
      min-width: 6rem;
      transition: color var(--transition), background var(--transition), border-color var(--transition);
    }

    .blockscape-tab.is-active {
      color: var(--color-text);
      background: var(--color-surface);
      border-color: var(--color-border);
      box-shadow: var(--color-shadow);
      position: relative;
      top: 1px;
    }

    .blockscape-tabpanels {
      border: 1px solid var(--color-border);
      border-radius: var(--radius-lg);
      background: var(--color-surface);
      box-shadow: var(--color-shadow);
    }

    .blockscape-tabpanel {
      display: none;
      padding: var(--space-lg);
    }

    .blockscape-tabpanel.is-active {
      display: block;
    }

    .blockscape-source-panel {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .blockscape-abstract {
      font-size: var(--font-size-sm);
      color: var(--blockscape-muted);
      line-height: 1.5;
      padding: var(--space-md);
      background: var(--blockscape-surface-alt);
      border-radius: var(--radius-md);
      border-left: 3px solid var(--blockscape-dep);
      margin: 0;
      box-shadow: var(--color-shadow);
    }

    .blockscape-abstract-panel {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .blockscape-abstract-placeholder {
      border: 1px dashed var(--color-border);
      border-radius: var(--radius-md);
      padding: var(--space-lg);
      background: var(--color-surface-muted);
      color: var(--blockscape-muted);
      font-size: var(--font-size-sm);
    }

    .blockscape-abstract a.blockscape-gist-link {
      color: var(--color-primary);
      font-weight: var(--font-weight-semibold);
      text-decoration: underline;
      cursor: pointer;
      word-break: break-all;
    }

    .blockscape-abstract a.blockscape-gist-link.is-loading {
      opacity: 0.65;
      pointer-events: none;
    }

    .category {
      margin: var(--space-lg) 0;
    }

    .blockscape-render {
      position: relative;
    }

    .blockscape-tab-tooltip {
      position: absolute;
      max-width: min(420px, calc(100% - 2 * var(--space-md)));
      padding: var(--space-md);
      background: var(--color-surface);
      box-shadow: var(--color-shadow);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      font-size: var(--font-size-sm);
      color: var(--blockscape-muted);
      z-index: 1000;
      pointer-events: none;
      transition: opacity var(--transition);
      opacity: 0;
    }

    .blockscape-tab-tooltip.is-visible {
      opacity: 1;
    }

    .cat-head {
      display: inline-flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-sm);
    }

    .cat-title {
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--blockscape-muted);
    }

    .cat-count {
      font-size: var(--font-size-xs);
      color: var(--color-muted);
    }

    .grid {
      position: relative;
      display: grid;
      grid-auto-rows: var(--blockscape-tile);
      grid-template-columns: repeat(auto-fill, minmax(var(--blockscape-tile), 1fr));
      gap: var(--blockscape-gap);
      padding: var(--blockscape-gap) 0;
      border-top: 1px dashed var(--blockscape-border);
    }

    .tile {
      position: relative;
      background: var(--blockscape-surface);
      border: 1px solid var(--blockscape-border);
      border-radius: var(--blockscape-radius);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      cursor: grab;
      transition: box-shadow var(--transition), transform var(--transition), border-color var(--transition);
      box-shadow: var(--color-shadow);
    }

    .tile:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 30px -24px rgba(15, 23, 42, 0.55);
    }

    .tile:active {
      transform: translateY(1px);
    }

    .tile.dragging {
      opacity: 0.5;
      cursor: grabbing;
      transform: rotate(4deg);
    }

    .tile.drag-over {
      border-color: var(--blockscape-dep);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
    }

    .grid.drag-active {
      background: var(--color-primary-soft);
    }

    .logo {
      width: 44px;
      height: 44px;
      object-fit: contain;
      opacity: .95;
    }

    .name {
      font-size: var(--font-size-xs);
      text-align: center;
      line-height: 1.15;
      padding: 0 var(--space-sm) var(--space-xs);
    }

    .badge {
      position: absolute;
      top: var(--space-sm);
      right: var(--space-sm);
      font-size: var(--font-size-xs);
      background: var(--color-warning-soft);
      color: var(--blockscape-reused);
      border: 1px solid var(--color-warning);
      border-radius: 999px;
      padding: 0.1rem 0.45rem;
      display: none;
      font-weight: var(--font-weight-medium);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .tile.reused .badge {
      display: inline-block;
    }

    .tile.external {
      border-style: dashed;
      border-color: var(--color-external);
      color: var(--blockscape-muted);
      background: #f8fafc;
    }

    .tile .external-link {
      position: absolute;
      top: var(--space-sm);
      left: var(--space-sm);
      width: 24px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: rgba(148, 163, 184, 0.16);
      color: inherit;
      font-size: 0.75rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
      transition: background var(--transition), color var(--transition), border var(--transition);
    }

    .tile .external-link:hover,
    .tile .external-link:focus-visible {
      background: rgba(148, 163, 184, 0.28);
      border-color: rgba(148, 163, 184, 0.45);
      color: var(--color-text);
    }

    .tile.dep {
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
      border-color: var(--blockscape-dep);
    }

    .tile.revdep {
      box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
      border-color: var(--blockscape-revdep);
    }

    .tile.selected {
      outline: 3px solid rgba(15, 23, 42, 0.25);
      outline-offset: 2px;
    }

    .muted {
      color: var(--blockscape-muted);
    }

    .svg-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 0;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .item-preview {
      --item-preview-width: min(420px, calc(100vw - 2 * var(--space-md)));
      --item-preview-height: min(70vh, calc(100vh - 2 * var(--space-md)));
      position: fixed;
      display: flex;
      flex-direction: column;
      width: var(--item-preview-width);
      max-height: var(--item-preview-height);
      background: var(--blockscape-surface);
      border: 1px solid var(--blockscape-border);
      border-radius: var(--radius-md);
      box-shadow: var(--color-shadow);
      opacity: 0;
      transform: translateY(4px);
      pointer-events: none;
      transition: opacity var(--transition), transform var(--transition);
      z-index: 999;
    }

    .item-preview--expanded {
      --item-preview-width: min(630px, calc(100vw - 2 * var(--space-md)));
      --item-preview-height: min(calc(100vh - 2 * var(--space-md)), 1200px);
    }

    .item-preview.is-visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .item-preview__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-xs);
      padding: var(--space-xs) var(--space-sm);
      border-bottom: 1px solid var(--color-border);
      background: var(--color-surface-muted);
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold);
    }

    .item-preview__title {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1 1 auto;
    }

    .item-preview__actions {
      display: flex;
      gap: var(--space-2xs);
      align-items: center;
      flex: 0 0 auto;
    }

    .item-preview__action {
      border: 1px solid var(--color-border);
      background: var(--color-surface);
      color: var(--blockscape-foreground);
      font-size: var(--font-size-xs);
      padding: var(--space-2xs) var(--space-sm);
      border-radius: var(--radius-sm);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
    }

    .item-preview__action:hover,
    .item-preview__action:focus-visible {
      background: var(--color-surface-muted);
      border-color: var(--color-border-strong);
    }

    .item-preview__close {
      border: none;
      background: transparent;
      color: var(--color-muted);
      cursor: pointer;
      font-size: 1.25rem;
      line-height: 1;
      border-radius: var(--radius-sm);
      padding: 0 var(--space-2xs);
    }

    .item-preview__close:hover,
    .item-preview__close:focus-visible {
      color: var(--blockscape-foreground);
      background: var(--color-surface-muted);
      outline: none;
    }

    .item-preview__body {
      flex: 1 1 auto;
      overflow: auto;
      padding: var(--space-sm);
      background: var(--blockscape-surface);
      font-size: var(--font-size-xs);
      line-height: 1.4;
    }

    .item-preview__frame {
      width: 100%;
      height: 100%;
      border: none;
      display: block;
    }

    .item-preview--has-frame .item-preview__body {
      padding: 0;
    }

    .item-preview__status {
      color: var(--color-muted);
    }

    @media (max-width: 1024px) {
      .blockscape-toolbar {
        padding: var(--space-sm) var(--space-md);
        gap: var(--space-sm);
      }

      .blockscape-content {
        flex-direction: column;
        gap: var(--space-md);
        width: calc(100% - 2 * var(--space-md));
        padding: var(--space-md) 0 var(--space-lg);
      }

      .blockscape-sidebar {
        width: 100%;
      }
    }

    @media (max-width: 720px) {
      .blockscape-toolbar {
        flex-direction: column;
        align-items: stretch;
      }

      .blockscape-content {
        width: calc(100% - 2 * var(--space-sm));
        gap: var(--space-sm);
      }

      .blockscape-brand {
        justify-content: space-between;
        width: 100%;
      }

      .blockscape-brand__logo {
        height: 44px;
      }

      .blockscape-toolbar__controls {
        width: 100%;
      }

      .blockscape-toolbar__controls .pf-v5-c-form-control,
      .blockscape-toolbar__controls .pf-v5-c-button {
        flex: 1 1 auto;
      }

      .blockscape-legend {
        width: 100%;
        justify-content: flex-start;
        margin-left: 0;
      }

      .blockscape-json-actions {
        width: 100%;
        flex-direction: row;
        justify-content: flex-start;
      }
    }
  </style>
</head>

<body>
  <div class="pf-v5-c-page">
    <header class="pf-v5-c-page__header">
      <div class="pf-v5-c-masthead pf-m-display-inline blockscape-masthead">
        <div class="pf-v5-c-masthead__content">
          <div class="blockscape-toolbar">
            <div class="blockscape-brand">
              <h1 class="sr-only">Blockscape</h1>
              <img class="blockscape-brand__logo" src="logos/blockscape-logo.svg"
                alt="Blockscape — landscape tile explorer" decoding="async" />
              <a href="https://github.com/pwright/blockscape" target="_blank"
                class="pf-v5-c-button pf-m-plain" title="View on GitHub" aria-label="View Blockscape on GitHub">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                  <path
                    d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
                </svg>
              </a>
            </div>
            <div class="blockscape-toolbar__controls">
              <label class="sr-only" for="search">Search tiles</label>
              <input id="search" class="pf-v5-c-form-control" type="text" placeholder="Search…" />
               
              <label class="sr-only" for="urlInput">Load JSON from URL</label>
              <input id="urlInput" class="pf-v5-c-form-control is-url" type="text"
                placeholder="Load JSON from URL…" /> 
                
              <button id="loadUrl" class="pf-v5-c-button pf-m-secondary" type="button">Load URL</button>
              
 
              <label class="pf-v5-c-button pf-m-secondary blockscape-file" role="button">
                <span>Load File(s)</span>
                <input id="file" type="file" accept=".json,.txt" multiple />
              </label>
 
              <button id="openInEditor" class="pf-v5-c-button pf-m-primary" type="button" title="Open current JSON in the editor">Edit</button>
              
              <button id="shareModel" class="pf-v5-c-button pf-m-primary" type="button" title="Copy a shareable URL for this model">Share</button>
              
              
            </div>
            <div class="blockscape-legend" role="presentation">
              <span class="legend-entry"><span class="legend-dot legend-dot--dep"></span> enables</span>
              <span class="legend-entry"><span class="legend-dot legend-dot--revdep"></span> dependents</span>
              <span class="legend-entry"><span class="legend-dot legend-dot--reused"></span> reused</span>
              <span class="legend-entry"><span class="legend-dot legend-dot--external"></span> external link</span>
            </div>
          </div>
        </div>
      </div>
    </header>

    <main class="pf-v5-c-page__main">
      <div class="blockscape-content">
        <aside class="blockscape-sidebar" aria-label="Models">
          <div class="sidebar-heading">Models</div>
          <ul id="modelList" class="model-nav-list"></ul>
          <div class="model-actions">
            <button id="removeModel" class="pf-v5-c-button pf-m-tertiary" type="button"
              title="Remove selected model">Remove active</button>
            <button id="clear" class="pf-v5-c-button pf-m-tertiary" type="button">Clear selection</button>
          </div>
        </aside>
        <div class="blockscape-main">
          <section class="pf-v5-c-page__main-section blockscape-json-panel" hidden
            aria-label="Model source JSON editor">
            <p class="blockscape-json-panel__title">Paste / edit JSON for the <b>active</b> model (schema below)</p>
            <div class="muted">
              Schema: <code>{ id, title, abstract?, categories:[{id,title,items:[{id,name,logo?,external?:url,color?,deps:[]}]}], links?:[{from,to}] }</code><br />
              You can paste multiple objects separated by <code>---</code> to append several models. A single object
              replaces only when you click “Replace active with JSON”.
            </div>
            <div class="blockscape-json-controls">
              <textarea id="jsonBox" class="pf-v5-c-form-control"
                aria-label="JSON editor for the active model"></textarea>
              <div class="blockscape-json-actions">
                <button id="appendFromBox" class="pf-v5-c-button pf-m-primary" type="button">Append model(s)</button>
                <button id="replaceActive" class="pf-v5-c-button pf-m-secondary" type="button">Replace active with
                  JSON</button>
              </div>
            </div>
          </section>

          <section class="pf-v5-c-page__main-section blockscape-main-section">
            <div id="app" aria-live="polite"></div>
          </section>
        </div>
      </div>
    </main>
  </div>

  <template id="seed">
    {
      "id": "blockscape",
      "title": "Understanding Blockscape",
      "abstract": "Blockscape is a tool for visualizing value chains and dependency relationships. It can be used to visualize the value chain of a project, a product, or a service. It can also be used to visualize the dependencies between different components of a project.<br>The tool enables users to understand dependencies, relationships, and value chains within a domain.<br>You can choose other data from left hand menu.<br>Or load data from a URL. Use https://github.com/pwright/blockscape/blob/main/model-generation-prompt.md  as a prompt to create JSON.<br>Select an item to see its dependencies.<br>Edit and Share to copy URL to clipboard<br>",
      "categories": [
        {
          "id": "communication",
          "title": "Communication",
          "items": [
            {
              "id": "gestalt",
              "name": "Visual schema",
              "deps": []
            },
            {
              "id": "spacial-memory",
              "name": "Spacial memory",
              "deps": []
            },
            {
              "id": "legend-literacy",
              "name": "Legend literacy",
              "deps": []
            },
            {
              "id": "icons",
              "name": "Iconography",
              "color": "#6aa9ff",
              "deps": []
            },
            {
              "id": "relational-awareness",
              "name": "Relational awareness",
              "color": "#6aa9ff",
              "deps": []
            }
          ]
        },
        {
          "id": "modeling",
          "title": "Modeling",
          "items": [
            {
              "id": "domain_prompt",
              "name": "Domain Prompt",
              "deps": [
                "relational-awareness"
              ]
            },
            {
              "id": "editor",
              "name": "Editor",
              "color": "#6aa9ff",
              "deps": [
                "model_components",
                "icons"
              ]
            },
            {
              "id": "domain_json",
              "name": "Domain JSON",
              "deps": [
                "domain_prompt"
              ]
            },
            {
              "id": "model_dependencies",
              "name": "Dependencies",
              "deps": [
                "model_components",
                "relational-awareness"
              ]
            },
            {
              "id": "model_components",
              "name": "Components and Categories",
              "deps": [
                "domain_json"
              ]
            }
          ]
        },
        {
          "id": "rendering",
          "title": "Rendering",
          "items": [
            {
              "id": "layout_engine",
              "name": "Layout Engine",
              "deps": [
                "model_components",
                "model_dependencies",
                "gestalt",
                "icons"
              ]
            },
            {
              "id": "value_visibility_axis",
              "name": "Vertical Position = Visible Value",
              "deps": [
                "layout_engine",
                "legend-literacy",
                "spacial-memory"
              ]
            },
            {
              "id": "evolution_axis",
              "name": "Horizontal Evolution (Optional)",
              "deps": [
                "layout_engine",
                "legend-literacy"
              ]
            }
          ]
        },
        {
          "id": "outputs",
          "title": "Outputs",
          "items": [
            {
              "id": "extendable",
              "name": "Extendable",
              "deps": [
                "domain_json"
              ]
            },
            {
              "id": "guideframe",
              "name": "Video creation",
              "deps": [
                "layout_engine",
                "value_visibility_axis",
                "evolution_axis"
              ]
            },
            {
              "id": "website",
              "name": "Website",
              "deps": [
                "layout_engine",
                "value_visibility_axis",
                "evolution_axis"
              ]
            },
            {
              "id": "git",
              "name": "Git/Gist",
              "deps": []
            },
            {
              "id": "share",
              "name": "Share",
              "color": "#6aa9ff",
              "deps": [
                "website"
              ]
            }
          ]
        }
      ]
    }
  </template>

  <svg id="overlay" class="svg-layer"></svg>
  <div id="tabTooltip" class="blockscape-tab-tooltip" hidden aria-hidden="true"></div>

  <div id="itemPreview" class="item-preview" hidden aria-hidden="true">
    <div class="item-preview__header">
      <span class="item-preview__title">Preview</span>
      <div class="item-preview__actions" hidden></div>
      <button type="button" class="item-preview__close" aria-label="Close preview">&times;</button>
    </div>
    <div class="item-preview__body">
      <div class="item-preview__status">Right-click a tile to see related notes.</div>
    </div>
  </div>

  <script>
    console.log("[Blockscape] init");

    const jsonBox = document.getElementById('jsonBox');
    const jsonPanel = document.querySelector('.blockscape-json-panel');
    const app = document.getElementById('app');
    const overlay = document.getElementById('overlay');
    const tabTooltip = document.getElementById('tabTooltip');
    const modelList = document.getElementById('modelList');
    const preview = document.getElementById('itemPreview');
  const previewTitle = preview.querySelector('.item-preview__title');
  const previewBody = preview.querySelector('.item-preview__body');
  const previewActions = preview.querySelector('.item-preview__actions');
  const previewClose = preview.querySelector('.item-preview__close');
    const downloadButton = document.getElementById('downloadJson');
    const shareButton = document.getElementById('shareModel');
    const editButton = document.getElementById('openInEditor');
    const EDITOR_TRANSFER_KEY = 'blockscape:editorPayload';

    // Show the seed in the editor initially.
    jsonBox.value = document.getElementById('seed').innerHTML.trim();

    // ===== State =====
    /** @type {{id:string,title:string,data:any}[]} */
    let models = [];
    let activeIndex = -1;

    let model = null;           // parsed result of active model: { m, fwd, rev, reusedLocal, seen }
    let index = new Map();      // id -> {el, catId, rect}
    let selection = null;
    let previewRequestId = 0;
    let previewAnchor = { x: 0, y: 0 };

    // ===== Utilities =====
    function uid() { return Math.random().toString(36).slice(2, 10); }

    function base64Encode(text) {
      const bytes = new TextEncoder().encode(text);
      let binary = '';
      bytes.forEach(b => { binary += String.fromCharCode(b); });
      return btoa(binary);
    }

    function base64Decode(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return new TextDecoder().decode(bytes);
    }

    function base64UrlEncode(text) {
      return base64Encode(text).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
    }

    function base64UrlDecode(token) {
      let base64 = token.replace(/-/g, '+').replace(/_/g, '/');
      const pad = base64.length % 4;
      if (pad) base64 += '='.repeat(4 - pad);
      return base64Decode(base64);
    }

    function download(filename, text) {
      const blob = new Blob([text], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    function makeDownloadName(base) {
      return (base || 'blockscape')
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9._-]+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '') || 'blockscape';
    }

    function ensureModelMetadata(data, { titleHint = 'Untitled Model', idHint } = {}) {
      if (!data || typeof data !== 'object') return data;
      const trimmedTitle = (data.title ?? '').toString().trim();
      data.title = trimmedTitle || titleHint || 'Untitled Model';

      const trimmedId = (data.id ?? '').toString().trim();
      if (!trimmedId) {
        const base = idHint || data.title || titleHint || 'model';
        const slug = makeDownloadName(base).replace(/\./g, '-');
        data.id = slug || `model-${uid()}`;
      } else {
        data.id = trimmedId;
      }

      if (typeof data.abstract !== 'string') {
        data.abstract = data.abstract == null ? '' : String(data.abstract);
      }
      return data;
    }

    function getModelTitle(entry, fallback = 'Untitled Model') {
      if (!entry) return fallback;
      const candidate = (entry.data?.title ?? entry.title ?? '').toString().trim();
      return candidate || fallback;
    }

    function getModelId(entry) {
      const candidate = entry?.data?.id;
      if (!candidate) return null;
      const trimmed = candidate.toString().trim();
      return trimmed || null;
    }

    function downloadCurrentJson(source = 'shortcut') {
      const text = jsonBox.value || '';
      if (!text.trim()) {
        console.warn("[Blockscape] download ignored: JSON box is empty.");
        return false;
      }
      const title = getModelTitle(models[activeIndex], 'blockscape');
      const filename = `${makeDownloadName(title)}.json`;
      download(filename, text);
      console.log(`[Blockscape] saved JSON (${source}):`, filename);
      return true;
    }

    // --- NEW: letter → color mapping and helpers ---
    // Letter → color mapping (tailwind-ish palette). G => green.
    const LETTER_COLOR_MAP = {
      A: '#ef4444', B: '#3b82f6', C: '#06b6d4', D: '#a855f7',
      E: '#f59e0b', F: '#f97316', G: '#22c55e', H: '#84cc16',
      I: '#10b981', J: '#14b8a6', K: '#0ea5e9', L: '#60a5fa',
      M: '#8b5cf6', N: '#d946ef', O: '#f43f5e', P: '#e11d48',
      Q: '#dc2626', R: '#f59e0b', S: '#eab308', T: '#a3e635',
      U: '#22d3ee', V: '#38bdf8', W: '#818cf8', X: '#a78bfa',
      Y: '#f472b6', Z: '#fb7185'
    };

    // Prefer explicit item.color (if present), else map by first letter.
    function getBadgeColor(text, explicit) {
      if (explicit && /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(explicit)) return explicit;
      const ch = (text || '?').charAt(0).toUpperCase();
      return LETTER_COLOR_MAP[ch] || '#9ca3af'; // fallback gray
    }

    // Compute readable letter color (black/white) against bg
    function idealTextColor(bgHex) {
      const hex = bgHex.replace('#', '');
      const expanded = hex.length === 3 ? hex.split('').map(c=>c+c).join('') : hex;
      const bigint = parseInt(expanded, 16);
      const r = (bigint >> 16) & 255, g = (bigint >> 8) & 255, b = bigint & 255;
      // luminance (sRGB)
      const L = 0.2126*Math.pow(r/255,2.2) + 0.7152*Math.pow(g/255,2.2) + 0.0722*Math.pow(b/255,2.2);
      return L > 0.35 ? '#111111' : '#ffffff';
    }

    function setActive(i) {
      hidePreview();
      if (i < 0 || i >= models.length) {
        console.warn("[Blockscape] setActive called with out-of-range index:", i);
        return;
      }
      activeIndex = i;
      console.log("[Blockscape] active model:", getModelTitle(models[i]), "(index", i + " )");
      renderModelList();
      loadActiveIntoEditor();
      rebuildFromActive();
    }

    function renderModelList() {
      modelList.innerHTML = "";
      if (!models.length) {
        const empty = document.createElement('li');
        empty.className = 'model-nav-empty';
        empty.textContent = 'No models loaded yet.';
        modelList.appendChild(empty);
        return;
      }

      models.forEach((m, i) => {
        const li = document.createElement('li');
        li.className = 'model-nav-item';

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'model-nav-button' + (i === activeIndex ? ' is-active' : '');
        btn.dataset.index = String(i);
        btn.setAttribute('aria-current', i === activeIndex ? 'true' : 'false');

        const label = document.createElement('span');
        label.className = 'model-nav-label';

        const titleSpan = document.createElement('span');
        titleSpan.className = 'model-nav-title';
        titleSpan.textContent = getModelTitle(m);
        label.appendChild(titleSpan);

        const dataId = getModelId(m);
        if (dataId) {
          const idBadge = document.createElement('span');
          idBadge.className = 'model-nav-id';
          idBadge.textContent = dataId;
          label.appendChild(idBadge);
        }

        const categories = Array.isArray(m.data?.categories) ? m.data.categories : [];
        const itemsCount = categories.reduce((sum, cat) => sum + ((cat.items || []).length), 0);

        const meta = document.createElement('span');
        meta.className = 'model-nav-meta';
        meta.textContent = `${categories.length} cat · ${itemsCount} items`;

        btn.appendChild(label);
        btn.appendChild(meta);
        li.appendChild(btn);
        modelList.appendChild(li);
      });
    }

    function loadActiveIntoEditor() {
      if (activeIndex < 0) { jsonBox.value = ""; return; }
      jsonBox.value = JSON.stringify(models[activeIndex].data, null, 2);
    }

    function tryParseJson(txt) { try { return JSON.parse(txt); } catch { return null; } }

    // Accept 1) object, 2) array-of-objects, 3) '---' separated objects
    function normalizeToModelsFromText(txt, titleBase = "Pasted") {
      const trimmed = (txt || "").trim();
      if (!trimmed) return [];
      const parsed = tryParseJson(trimmed);
      if (parsed) {
        const arr = Array.isArray(parsed) ? parsed : [parsed];
        return arr.map((o, idx) => {
          ensureModelMetadata(o, { titleHint: `${titleBase} #${idx + 1}` });
          return {
            id: uid(),
            title: o.title || `${titleBase} #${idx + 1}`,
            data: o
          };
        });
      }
      const parts = trimmed.split(/^\s*---\s*$/m).map(s => s.trim()).filter(Boolean);
      return parts.map((p, i) => {
        const obj = JSON.parse(p);
        ensureModelMetadata(obj, { titleHint: `${titleBase} #${i + 1}` });
        return {
          id: uid(),
          title: obj.title || `${titleBase} #${i + 1}`,
          data: obj
        };
      });
    }

    function consumeEditorPayload() {
      if (typeof window === 'undefined' || !window.localStorage) return null;
      let raw;
      try {
        raw = localStorage.getItem(EDITOR_TRANSFER_KEY);
      } catch (err) {
        console.warn('[Blockscape] failed to access editor payload', err);
        return null;
      }
      if (!raw) return null;
      let payload;
      try {
        payload = JSON.parse(raw);
      } catch (err) {
        console.warn('[Blockscape] invalid payload JSON', err);
        try { localStorage.removeItem(EDITOR_TRANSFER_KEY); } catch (_) {}
        return null;
      }
      if (payload?.source !== 'editor') return null;
      try {
        localStorage.removeItem(EDITOR_TRANSFER_KEY);
      } catch (err) {
        console.warn('[Blockscape] failed to clear editor payload', err);
      }
      if (!payload.text || typeof payload.text !== 'string') {
        console.warn('[Blockscape] payload missing text');
        return null;
      }
      let entries = [];
      try {
        entries = normalizeToModelsFromText(payload.text, payload.title || 'Editor Export');
      } catch (err) {
        console.warn('[Blockscape] could not parse payload text', err);
        return null;
      }
      if (!entries.length) return null;
      const startIndex = models.length;
      entries.forEach(entry => models.push(entry));
      console.log(`[Blockscape] imported ${entries.length} model(s) from editor`);
      return startIndex;
    }

    function consumeShareLink() {
      const hash = window.location.hash || '';
      let token = null;
      let source = null;

      const hashMatch = hash.match(/share=([^&]+)/);
      if (hashMatch) {
        token = hashMatch[1];
        source = 'hash';
      }

      if (!token) {
        const params = new URLSearchParams(window.location.search);
        if (params.has('share')) {
          token = params.get('share');
          source = 'search';
        }
      }

      if (!token) return null;

      let payload;
      try {
        const text = base64UrlDecode(token);
        payload = JSON.parse(text);
      } catch (err) {
        console.warn('[Blockscape] failed to decode share token', err);
        return null;
      }

      if (!payload || typeof payload !== 'object' || typeof payload.data !== 'object') {
        console.warn('[Blockscape] share payload missing data');
        return null;
      }

      ensureModelMetadata(payload.data, { titleHint: payload.title || 'Shared Model' });

      models.push({
        id: uid(),
        title: payload.data.title || payload.title || 'Shared Model',
        data: payload.data
      });

      if (source === 'hash') {
        history.replaceState(null, '', window.location.pathname + window.location.search);
      } else if (source === 'search') {
        const params = new URLSearchParams(window.location.search);
        params.delete('share');
        const newSearch = params.toString();
        history.replaceState(null, '', window.location.pathname + (newSearch ? `?${newSearch}` : ''));
      }

      return models.length - 1;
    }

    function parse(mObj) {
      console.log("[Blockscape] parsing model; categories=", (mObj?.categories || []).length);
      const fwd = new Map();
      const rev = new Map();
      const seen = new Set();

      (mObj.categories || []).forEach(c => (c.items || []).forEach(it => {
        seen.add(it.id);
        const deps = new Set(it.deps || []);
        (mObj.links || []).forEach(l => { if (l.from === it.id) deps.add(l.to); });
        fwd.set(it.id, deps);
        deps.forEach(d => {
          if (!rev.has(d)) rev.set(d, new Set());
          rev.get(d).add(it.id);
        });
      }));

      const reusedLocal = new Set();
      rev.forEach((dependents, node) => { if ((dependents?.size || 0) >= 2) reusedLocal.add(node); });
      return { m: mObj, fwd, rev, reusedLocal, seen };
    }

    // --- MODIFIED: color-aware letter image ---
    function generateLetterImage(text, explicitColor) {
      console.log("[Blockscape] generateLetterImage for:", text);
      const canvas = document.createElement('canvas');
      const size = 44;
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext('2d');

      const letter = (text || '?').charAt(0).toUpperCase();
      const bg = getBadgeColor(text, explicitColor);
      const fg = idealTextColor(bg);

      // Circle
      ctx.fillStyle = bg;
      ctx.beginPath();
      ctx.arc(size/2, size/2, size/2 - 2, 0, 2*Math.PI);
      ctx.fill();

      // Subtle ring
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Letter
      ctx.fillStyle = fg;
      ctx.font = `bold ${size * 0.5}px system-ui, -apple-system, sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(letter, size/2, size/2);

      return canvas.toDataURL('image/png');
    }

    // ===== Render =====
    function render() {
      if (!model) return;
      hideTabTooltip();
      console.log("[Blockscape] rendering categories=", model.m.categories.length);
      console.log("[Blockscape] model.m has abstract?", !!model.m.abstract, "- value:", model.m.abstract ? model.m.abstract.substring(0, 50) + "..." : "none");
      app.innerHTML = "";
      index.clear();

      overlay.setAttribute("width", window.innerWidth);
      overlay.setAttribute("height", window.innerHeight);

      const meta = document.createElement('div');
      meta.className = 'blockscape-model-meta';

      const titleEl = document.createElement('div');
      titleEl.className = 'blockscape-model-title';
      titleEl.textContent = (model.m.title && model.m.title.trim()) || getModelTitle(models[activeIndex]);
      meta.appendChild(titleEl);

      const normalizedId = (model.m.id ?? '').toString().trim();
      if (normalizedId) {
        const idEl = document.createElement('div');
        idEl.className = 'blockscape-model-id';
        idEl.textContent = `ID: ${normalizedId}`;
        meta.appendChild(idEl);
      }

      app.appendChild(meta);
      const tabsWrapper = document.createElement('div');
      tabsWrapper.className = 'blockscape-tabs';

      const tabList = document.createElement('div');
      tabList.className = 'blockscape-tablist';
      tabList.setAttribute('role', 'tablist');
      tabsWrapper.appendChild(tabList);

      const panelsWrapper = document.createElement('div');
      panelsWrapper.className = 'blockscape-tabpanels';
      tabsWrapper.appendChild(panelsWrapper);

      const mapPanel = document.createElement('div');
      const abstractPanel = document.createElement('div');
      const sourcePanel = document.createElement('div');
      let infoTooltipHtml = '';

      const tabDefs = [
        { id: 'map', label: 'Map', panel: mapPanel },
        { id: 'abstract', label: 'Info', panel: abstractPanel },
        { id: 'source', label: 'Source', panel: sourcePanel }
      ];

      const handleTabVisibility = (tabId) => {
        if (!overlay) return;
        const showOverlay = tabId === 'map';
        overlay.hidden = !showOverlay;
        if (showOverlay) {
          reflowRects();
          drawLinks();
        } else {
          overlay.innerHTML = '';
        }
      };

      tabDefs.forEach((tab, idx) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.id = `tab-${tab.id}`;
        button.className = 'blockscape-tab' + (idx === 0 ? ' is-active' : '');
        button.setAttribute('role', 'tab');
        button.setAttribute('aria-controls', `panel-${tab.id}`);
        button.setAttribute('aria-selected', idx === 0 ? 'true' : 'false');
        button.textContent = tab.label;
        tab.button = button;
        tabList.appendChild(button);

        tab.panel.id = `panel-${tab.id}`;
        tab.panel.classList.add('blockscape-tabpanel');
        tab.panel.setAttribute('role', 'tabpanel');
        tab.panel.setAttribute('aria-labelledby', button.id);
        tab.panel.hidden = idx === 0 ? false : true;
        if (idx === 0) tab.panel.classList.add('is-active');
        panelsWrapper.appendChild(tab.panel);
      });

      const activateTab = (targetId) => {
        tabDefs.forEach(t => {
          const isActive = t.id === targetId;
          t.button.classList.toggle('is-active', isActive);
          t.button.setAttribute('aria-selected', isActive ? 'true' : 'false');
          t.panel.classList.toggle('is-active', isActive);
          t.panel.hidden = !isActive;
        });
        handleTabVisibility(targetId);
      };

      tabDefs.forEach(t => {
        t.button.addEventListener('click', () => {
          hideTabTooltip();
          activateTab(t.id);
        });
        if (t.id === 'abstract') {
          t.button.addEventListener('mouseenter', () => showTabTooltip(t.button, infoTooltipHtml, { offset: 12 }));
          t.button.addEventListener('mouseleave', hideTabTooltip);
          t.button.addEventListener('focus', () => showTabTooltip(t.button, infoTooltipHtml, { offset: 12 }));
          t.button.addEventListener('blur', hideTabTooltip);
        }
      });

      activateTab(tabDefs[0].id);

      app.appendChild(tabsWrapper);

      const renderHost = document.createElement('div');
      renderHost.className = 'blockscape-render';
      mapPanel.appendChild(renderHost);

      const abstractWrapper = document.createElement('div');
      abstractWrapper.className = 'blockscape-abstract-panel';
      if (model.m.abstract) {
        console.log("[Blockscape] Rendering abstract content");
        const abstractDiv = document.createElement('div');
        abstractDiv.className = 'blockscape-abstract';
        abstractDiv.innerHTML = model.m.abstract;
        enhanceAbstractWithGistLinks(abstractDiv);
        abstractWrapper.appendChild(abstractDiv);
        infoTooltipHtml = abstractDiv.outerHTML;
      } else {
        console.log("[Blockscape] No abstract found in model.m");
        const placeholder = document.createElement('div');
        placeholder.className = 'blockscape-abstract-placeholder';
        placeholder.textContent = 'No abstract has been provided for this model.';
        abstractWrapper.appendChild(placeholder);
        infoTooltipHtml = placeholder.outerHTML;
      }
      abstractPanel.appendChild(abstractWrapper);

      const sourceWrapper = document.createElement('div');
      sourceWrapper.className = 'blockscape-source-panel';
      if (jsonPanel) {
        jsonPanel.hidden = false;
        jsonPanel.classList.remove('pf-v5-c-page__main-section');
        sourceWrapper.appendChild(jsonPanel);
      } else {
        const missing = document.createElement('p');
        missing.className = 'muted';
        missing.textContent = 'Source editor unavailable.';
        sourceWrapper.appendChild(missing);
      }
      sourcePanel.appendChild(sourceWrapper);

      model.m.categories.forEach(cat => {
        const section = document.createElement('section');
        section.className = 'category';
        section.dataset.cat = cat.id;

        const head = document.createElement('div');
        head.className = 'cat-head';
        head.innerHTML = `<div class="cat-title">${escapeHtml(cat.title || cat.id)}</div>
                          <div class="muted cat-count">${(cat.items || []).length} items</div>`;
        section.appendChild(head);

        const grid = document.createElement('div');
        grid.className = 'grid';
        section.appendChild(grid);

        (cat.items || []).forEach(it => {
          const externalMeta = resolveExternalMeta(it.external);
          const tile = document.createElement('div');
          tile.className = externalMeta.isExternal ? 'tile external' : 'tile';
          tile.tabIndex = 0;
          tile.dataset.id = it.id;
          if (externalMeta.url) { tile.dataset.externalUrl = externalMeta.url; }

          const img = document.createElement('img');
          img.className = 'logo';
          if (it.logo) {
            img.src = it.logo; img.alt = it.name || it.id;
          } else {
            img.alt = "";
            img.style.opacity = 1; // colored letter icon is the intended visual
            img.src = generateLetterImage(it.name || it.id, it.color); // supports optional per-item color
          }

          const nm = document.createElement('div');
          nm.className = 'name';
          nm.textContent = it.name || it.id;

          const badge = document.createElement('div');
          badge.className = 'badge';
          badge.textContent = 'reused';

          if (externalMeta.url) {
            tile.appendChild(createExternalLinkButton(externalMeta.url));
          }
          tile.appendChild(img);
          tile.appendChild(nm);
          tile.appendChild(badge);
          grid.appendChild(tile);

          index.set(it.id, { el: tile, catId: cat.id, rect: null });
        });

        renderHost.appendChild(section);
      });

      model.reusedLocal.forEach(id => {
        const hit = index.get(id);
        if (hit) {
          hit.el.classList.add('reused');
          hit.el.querySelector('.badge').style.display = 'inline-block';
        }
      });

      wireEvents();
      reflowRects();
      drawLinks();
    }

    function wireEvents() {
      app.querySelectorAll('.tile').forEach(t => {
        t.addEventListener('click', (event) => {
          if (typeof event.button === 'number' && event.button !== 0) return;
          hidePreview();
          const id = t.dataset.id;
          console.log("[Blockscape] click", id);
          if (selection === id) { clearSelection(); return; }
          select(id);
        });
        t.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); t.click(); }
        });
        t.draggable = true;
        t.addEventListener('dragstart', handleDragStart);
        t.addEventListener('dragend', handleDragEnd);
      });

      app.querySelectorAll('.grid').forEach(grid => {
        grid.addEventListener('dragover', handleDragOver);
        grid.addEventListener('drop', handleDrop);
        grid.addEventListener('dragenter', handleDragEnter);
        grid.addEventListener('dragleave', handleDragLeave);
      });

      window.addEventListener('resize', () => { reflowRects(); drawLinks(); });
      document.getElementById('clear').onclick = () => clearSelection();
    }

    function reflowRects() { index.forEach((v) => { v.rect = v.el.getBoundingClientRect(); }); }

    function select(id) {
      selection = id;
      clearStyles();
      const deps = Array.from(model.fwd.get(id) || []);
      const revs = Array.from(model.rev.get(id) || []);
      console.log("[Blockscape] selecting id=", id, "deps=", deps, "revs=", revs);
      const sel = index.get(id); if (sel) sel.el.classList.add('selected');
      deps.forEach(d => { const hit = index.get(d); if (hit) hit.el.classList.add('dep'); });
      revs.forEach(r => { const hit = index.get(r); if (hit) hit.el.classList.add('revdep'); });
      drawLinks();
    }

    function clearSelection() { selection = null; clearStyles(); drawLinks(); }
    function clearStyles() { app.querySelectorAll('.tile').forEach(t => t.classList.remove('dep', 'revdep', 'selected')); }

    function drawLinks() {
      while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
      if (!selection || overlay.hidden) return;

      const fromRect = index.get(selection)?.rect;
      if (!fromRect) return;

      const toList = new Set([...(model.fwd.get(selection) || []), ...(model.rev.get(selection) || [])]);
      toList.forEach(to => {
        const target = index.get(to);
        if (!target || !target.rect) return;
        const a = center(fromRect);
        const b = center(target.rect);
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const c1x = (a.x + b.x) / 2, c1y = a.y;
        const c2x = (a.x + b.x) / 2, c2y = b.y;
        const isDep = (model.fwd.get(selection) || new Set()).has(to);
        path.setAttribute("d", `M ${a.x},${a.y} C ${c1x},${c1y} ${c2x},${c2y} ${b.x},${b.y}`);
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", isDep ? "var(--blockscape-dep)" : "var(--blockscape-revdep)");
        path.setAttribute("stroke-opacity", "0.45");
        path.setAttribute("stroke-width", "2");
        path.setAttribute("vector-effect", "non-scaling-stroke");
        overlay.appendChild(path);
      });
    }

    function center(r) { return { x: r.left + r.width / 2, y: r.top + r.height / 2 }; }
    function escapeHtml(s) { return s.replace(/[&<>"']/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" }[m])); }

    function resolveExternalMeta(value) {
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) return { isExternal: false, url: '' };
        try {
          const url = new URL(trimmed);
          if (!/^https?:/i.test(url.protocol)) return { isExternal: false, url: '' };
          return { isExternal: true, url: url.toString() };
        } catch (error) {
          console.warn('[Blockscape] invalid external url skipped', value, error);
          return { isExternal: false, url: '' };
        }
      }
      if (value === true) {
        return { isExternal: true, url: '' };
      }
      return { isExternal: false, url: '' };
    }

    function createExternalLinkButton(url) {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'external-link';
      button.setAttribute('aria-label', 'Open external reference in a new tab');
      button.title = url;
      button.textContent = '↗';
      button.addEventListener('click', (event) => {
        event.stopPropagation();
        window.open(url, '_blank', 'noopener');
      });
      button.addEventListener('keydown', (event) => event.stopPropagation());
      return button;
    }

    function showTabTooltip(target, html, { offset = 8 } = {}) {
      if (!tabTooltip || !target || !html) return;
      tabTooltip.innerHTML = html;
      tabTooltip.hidden = false;
      tabTooltip.setAttribute('aria-hidden', 'false');
      requestAnimationFrame(() => {
        const rect = target.getBoundingClientRect();
        const tooltipRect = tabTooltip.getBoundingClientRect();
        const scrollX = window.scrollX || document.documentElement.scrollLeft;
        const scrollY = window.scrollY || document.documentElement.scrollTop;
        let left = rect.left + rect.width / 2 - tooltipRect.width / 2 + scrollX;
        let top = rect.top - tooltipRect.height - offset + scrollY;
        if (left < scrollX + offset) left = scrollX + offset;
        const maxLeft = scrollX + window.innerWidth - tooltipRect.width - offset;
        if (left > maxLeft) left = maxLeft;
        if (top < scrollY + offset) top = rect.bottom + offset + scrollY;
        tabTooltip.style.left = `${left}px`;
        tabTooltip.style.top = `${top}px`;
        tabTooltip.classList.add('is-visible');
      });
    }

    function hideTabTooltip() {
      if (!tabTooltip) return;
      tabTooltip.classList.remove('is-visible');
      tabTooltip.setAttribute('aria-hidden', 'true');
      tabTooltip.hidden = true;
    }

    window.addEventListener('scroll', hideTabTooltip, true);
    window.addEventListener('resize', hideTabTooltip);

    function hidePreview() {
      if (!preview) return;
      preview.classList.remove('is-visible', 'item-preview--has-frame', 'item-preview--expanded');
      preview.setAttribute('aria-hidden', 'true');
      preview.hidden = true;
      setPreviewActions('');
    }

    function showPreviewAt(x, y) {
      if (!preview) return;
      previewAnchor = { x, y };
      preview.hidden = false;
      preview.setAttribute('aria-hidden', 'false');
      preview.classList.add('is-visible');
      positionPreview(x, y);
    }

    function positionPreview(x, y) {
      if (!preview) return;
      const margin = 12;
      preview.style.left = `${x + margin}px`;
      preview.style.top = `${y + margin}px`;
      const rect = preview.getBoundingClientRect();
      let left = rect.left;
      let top = rect.top;
      if (rect.right > window.innerWidth - margin) {
        left = Math.max(margin, window.innerWidth - rect.width - margin);
      }
      if (rect.bottom > window.innerHeight - margin) {
        top = Math.max(margin, window.innerHeight - rect.height - margin);
      }
      preview.style.left = `${left}px`;
      preview.style.top = `${top}px`;
    }

    function setPreviewActions(url) {
      if (!previewActions) return;
      previewActions.innerHTML = '';
      if (url) {
        const action = document.createElement('button');
        action.type = 'button';
        action.className = 'item-preview__action';
        action.innerHTML = 'Open external link <span aria-hidden="true">↗</span>';
        action.title = url;
        action.addEventListener('click', (event) => {
          event.stopPropagation();
          window.open(url, '_blank', 'noopener');
        });
        previewActions.appendChild(action);
        previewActions.hidden = false;
      } else {
        previewActions.hidden = true;
      }
    }

    async function handleTileContextMenu(event, tile) {
      if (!preview) return;
      event.stopPropagation();
      event.preventDefault();
      const id = tile.dataset.id;
      const displayName = tile.querySelector('.name')?.textContent || id || 'Preview';
      const filename = id ? `${id}.html` : '';
      const filepath = filename ? `items/${filename}` : '';
      const requestId = ++previewRequestId;
      const externalUrl = tile.dataset.externalUrl || '';
      setPreviewActions(externalUrl);

      previewTitle.textContent = displayName;
      previewBody.innerHTML = '<div class="item-preview__status">Loading…</div>';
      preview.classList.remove('item-preview--has-frame');
      preview.classList.add('item-preview--expanded');
      showPreviewAt(event.clientX, event.clientY);

      if (!filepath) {
        previewBody.innerHTML = '<div class="item-preview__status">Preview unavailable for this item.</div>';
        positionPreview(previewAnchor.x, previewAnchor.y);
        return;
      }

      try {
        const response = await fetch(filepath, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const html = await response.text();
        if (requestId !== previewRequestId) return;
        const trimmed = html.trim();
        if (!trimmed) {
          previewBody.innerHTML = `<div class="item-preview__status">No content in <code>${escapeHtml(filename)}</code>.</div>`;
          positionPreview(previewAnchor.x, previewAnchor.y);
          return;
        }
        const frame = document.createElement('iframe');
        frame.className = 'item-preview__frame';
        frame.title = `${displayName} details`;
        frame.srcdoc = html;
        previewBody.innerHTML = '';
        previewBody.appendChild(frame);
        preview.classList.add('item-preview--has-frame');
        positionPreview(previewAnchor.x, previewAnchor.y);
      } catch (error) {
        if (requestId !== previewRequestId) return;
        previewBody.innerHTML = `<div class="item-preview__status">No preview available for <strong>${escapeHtml(displayName)}</strong>.</div>`;
        console.warn(`[Blockscape] preview unavailable for ${filepath}`, error);
        positionPreview(previewAnchor.x, previewAnchor.y);
      }
    }

    if (previewClose) {
      previewClose.addEventListener('click', hidePreview);
    }

    if (app) {
      app.addEventListener('contextmenu', (event) => {
        const tile = event.target.closest('.tile');
        if (!tile || !app.contains(tile)) return;
        handleTileContextMenu(event, tile);
      });
    }

    document.addEventListener('click', (event) => {
      if (typeof event.button === 'number' && event.button !== 0) return;
      if (!preview || preview.hidden) return;
      if (preview.contains(event.target)) return;
      hidePreview();
    });

    if (downloadButton) {
      downloadButton.addEventListener('click', () => {
        downloadCurrentJson('button');
      });
    }

    if (shareButton) {
      shareButton.addEventListener('click', async () => {
        if (activeIndex < 0 || !models[activeIndex]) {
          alert('Select or load a model before sharing.');
          return;
        }
        const payload = {
          title: getModelTitle(models[activeIndex], 'Shared Model'),
          data: models[activeIndex].data
        };
        let encoded;
        try {
          encoded = base64UrlEncode(JSON.stringify(payload));
        } catch (err) {
          console.error('[Blockscape] share encode failed', err);
          alert('Unable to encode this model for sharing.');
          return;
        }
        const shareUrl = new URL(window.location.href);
        shareUrl.searchParams.delete('share');
        shareUrl.hash = `share=${encoded}`;
        const fullUrl = shareUrl.toString();

        let copied = false;
        if (navigator.clipboard?.writeText) {
          try {
            await navigator.clipboard.writeText(fullUrl);
            copied = true;
          } catch (err) {
            console.warn('[Blockscape] clipboard write failed', err);
          }
        }
        if (copied) {
          alert('Share URL copied to clipboard.');
        } else {
          window.prompt('Copy this share URL:', fullUrl);
        }
      });
    }

    if (editButton) {
      editButton.addEventListener('click', () => {
        const text = (jsonBox.value || '').trim();
        if (!text) {
          alert('Load or paste a model before opening the editor.');
          return;
        }
        try {
          JSON.parse(text);
        } catch (err) {
          alert('Current JSON is invalid. Fix it before opening the editor.');
          return;
        }
        try {
          const payload = {
            ts: Date.now(),
            text,
            source: 'viewer'
          };
          if (selection) {
            payload.selectedItemId = selection;
          }
          localStorage.setItem(EDITOR_TRANSFER_KEY, JSON.stringify(payload));
        } catch (storageError) {
          console.error('[Blockscape] failed to store editor payload', storageError);
          alert('Unable to stash JSON for the editor (storage disabled?).');
          return;
        }
        let editorUrl = 'editor.html#viewer';
        if (selection) {
          const encoded = encodeURIComponent(selection);
          editorUrl = `editor.html?selected=${encoded}#viewer`;
        }
        window.open(editorUrl, '_blank');
      });
    }

    document.addEventListener('keydown', (event) => {
      if ((event.ctrlKey || event.metaKey) && event.code === 'KeyS') {
        event.preventDefault();
        downloadCurrentJson('shortcut');
        return;
      }

      if (event.key === 'Escape' && preview && !preview.hidden) {
        hidePreview();
      }
    });

    window.addEventListener('resize', () => {
      if (!preview || preview.hidden) return;
      positionPreview(previewAnchor.x, previewAnchor.y);
    });

    window.addEventListener('scroll', () => {
      if (!preview || preview.hidden) return;
      hidePreview();
    }, true);

    // ===== Drag and drop reorder (per model) =====
    let draggedItemId = null;
    let draggedCategoryId = null;

    function handleDragStart(e) {
      hidePreview();
      draggedItemId = e.target.dataset.id;
      draggedCategoryId = e.target.closest('.category').dataset.cat;

      e.target.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', JSON.stringify({
        itemId: draggedItemId,
        categoryId: draggedCategoryId
      }));

      const category = e.target.closest('.category');
      const grid = category.querySelector('.grid');
      grid.classList.add('drag-active');

      console.log("[Blockscape] drag start", draggedItemId, "from", draggedCategoryId);
    }

    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
      app.querySelectorAll('.grid').forEach(grid => grid.classList.remove('drag-active'));
      app.querySelectorAll('.tile').forEach(tile => tile.classList.remove('drag-over'));
      draggedItemId = null;
      draggedCategoryId = null;
    }

    function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }
    function handleDragEnter(e) {
      e.preventDefault();
      const grid = e.target.closest('.grid');
      if (grid) grid.classList.add('drag-active');
    }
    function handleDragLeave(e) {
      const grid = e.target.closest('.grid');
      if (grid && !grid.contains(e.relatedTarget)) grid.classList.remove('drag-active');
    }

    function handleDrop(e) {
      e.preventDefault();
      const targetGrid = e.target.closest('.grid');
      const targetCategory = targetGrid.closest('.category');
      const targetCategoryId = targetCategory.dataset.cat;

      if (!draggedItemId || !targetCategoryId) return;
      if (draggedCategoryId !== targetCategoryId) {
        console.log("[Blockscape] drop rejected - different category");
        return;
      }

      const tiles = Array.from(targetGrid.querySelectorAll('.tile'));
      const targetTile = tiles.find(tile => {
        const rect = tile.getBoundingClientRect();
        return e.clientY < rect.top + rect.height / 2;
      });

      reorderItem(draggedItemId, targetTile ? targetTile.dataset.id : null, targetCategoryId);
      render();
      console.log("[Blockscape] drop completed", draggedItemId, "in", targetCategoryId);
    }

    function reorderItem(itemId, targetItemId, categoryId) {
      if (activeIndex < 0) return;
      const mobj = models[activeIndex].data;
      const category = (mobj.categories || []).find(cat => cat.id === categoryId);
      if (!category) return;

      const itemIndex = (category.items || []).findIndex(item => item.id === itemId);
      if (itemIndex === -1) return;

      const [movedItem] = category.items.splice(itemIndex, 1);
      if (targetItemId) {
        const targetIndex = category.items.findIndex(item => item.id === targetItemId);
        if (targetIndex !== -1) category.items.splice(targetIndex, 0, movedItem);
        else category.items.push(movedItem);
      } else {
        category.items.push(movedItem);
      }
      // keep editor in sync
      loadActiveIntoEditor();
      rebuildFromActive();
    }

    // ===== Controls =====

    // Append models from textarea
    document.getElementById('appendFromBox').onclick = () => {
      try {
        const appended = normalizeToModelsFromText(jsonBox.value, "Pasted");
        if (!appended.length) { alert("No valid JSON found to append."); return; }
        console.log("[Blockscape] appending", appended.length, "model(s)");
        models.push(...appended);
        if (activeIndex === -1) setActive(0); else { renderModelList(); }
      } catch (e) {
        console.error("[Blockscape] append error:", e);
        alert("Append error (see console).");
      }
    };

    // Replace active model data with JSON from textarea
    document.getElementById('replaceActive').onclick = () => {
      if (activeIndex < 0) { alert("No active model selected."); return; }
      try {
        const obj = JSON.parse(jsonBox.value);
        ensureModelMetadata(obj, { 
          titleHint: getModelTitle(models[activeIndex]), 
          idHint: getModelId(models[activeIndex]) || getModelTitle(models[activeIndex]) 
        });
        models[activeIndex].data = obj;
        models[activeIndex].title = obj.title || models[activeIndex].title;
        console.log("[Blockscape] replaced active model:", getModelTitle(models[activeIndex]));
        rebuildFromActive();
      } catch (e) {
        console.error("[Blockscape] replace error:", e);
        alert("JSON parse error (see console).");
      }
    };

    // Load files: each text may be single object, array, or --- separated
    document.getElementById('file').onchange = async (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;
      try {
        console.log("[Blockscape] reading", files.length, "file(s)");
        for (const f of files) {
          const txt = await f.text();
          const entries = normalizeToModelsFromText(txt, f.name.replace(/\.[^.]+$/, '') || "File");
          if (!entries.length) {
            console.warn("[Blockscape] no models in file:", f.name);
            continue;
          }
          // Ensure file-derived entries prefer embedded title/id but fall back to filename
          models.push(...entries.map((en, i) => {
            const dataTitle = (en.data?.title ?? '').toString().trim();
            const fallbackTitle = entries.length > 1 ? `${f.name} #${i + 1}` : f.name;
            return { ...en, title: dataTitle || fallbackTitle };
          }));
        }
        if (activeIndex === -1 && models.length) setActive(0);
        else renderModelList();
      } catch (err) {
        console.error("[Blockscape] file load error:", err);
        alert("File load error (see console).");
      } finally {
        e.target.value = ""; // allow re-selecting the same files
      }
    };

    // Switch active model from sidebar
    modelList.addEventListener('click', (e) => {
      const button = e.target.closest('button[data-index]');
      if (!button) return;
      const i = parseInt(button.dataset.index, 10);
      if (!Number.isInteger(i)) return;
      setActive(i);
    });

    // Remove selected model
    document.getElementById('removeModel').onclick = () => {
      if (activeIndex < 0) return;
      console.log("[Blockscape] removing model:", getModelTitle(models[activeIndex]));
      models.splice(activeIndex, 1);
      if (!models.length) {
        activeIndex = -1;
        model = null;
        app.innerHTML = "";
        overlay.innerHTML = "";
        jsonBox.value = "";
        renderModelList();
        return;
      }
      const next = Math.min(activeIndex, models.length - 1);
      setActive(next);
    };

    // Search filter
    document.getElementById('search').addEventListener('input', (e) => {
      const q = e.target.value.trim().toLowerCase();
      console.log("[Blockscape] search:", q);
      app.querySelectorAll('.tile').forEach(t => {
        const name = t.querySelector('.name').textContent.toLowerCase();
        t.style.opacity = (!q || name.includes(q)) ? 1 : .2;
      });
    });

    // Load from URL
    document.getElementById('loadUrl').addEventListener('click', async () => {
      const url = document.getElementById('urlInput').value.trim();
      if (!url) {
        alert("Please enter a URL");
        return;
      }
      await loadFromUrl(url);
      document.getElementById('urlInput').value = ''; // Clear input after successful load
    });

    // Allow Enter key in URL input
    document.getElementById('urlInput').addEventListener('keydown', async (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.getElementById('loadUrl').click();
      }
    });

    // Helpers
    function rebuildFromActive() {
      if (activeIndex < 0) return;
      try {
        const parsed = parse(models[activeIndex].data);
        model = parsed;
        render();
      } catch (e) {
        console.error("[Blockscape] rebuild error (active model likely malformed):", e);
        alert("Active model parse/render error (see console).");
      }
    }

    // Load JSON files from same directory (for static hosting)
    async function loadJsonFiles() {
      const jsonFiles = ['NFR.bs', 'deploy.bs'];
      
      for (const filename of jsonFiles) {
        try {
          const response = await fetch(filename, { cache: 'no-store' });
          if (!response.ok) continue;

          const text = await response.text();
          const baseName = filename.replace(/\.[^.]+$/, '') || 'Model';
          const entries = normalizeToModelsFromText(text, baseName);
          if (!entries.length) {
            console.warn("[Blockscape] no models found in", filename);
            continue;
          }

          models.push(...entries);
          console.log(`[Blockscape] loaded ${entries.length} model(s) from ${filename}`);
        } catch (error) {
          console.log("[Blockscape] could not load", filename, "- this is normal for file:// protocol");
        }
      }
    }

    async function fetchTextWithCacheBypass(url) {
      const attempts = [
        { cache: 'no-store' },
        { cache: 'reload' },
        {}
      ];
      let lastError = null;
      for (const opts of attempts) {
        try {
          console.log(`[Blockscape] fetching ${url} with cache="${opts.cache ?? 'default'}"`);
          const response = await fetch(url, opts);
          if (response.status === 304) {
            console.warn("[Blockscape] fetch returned 304 (Not Modified), retrying without cache");
            continue;
          }
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          return await response.text();
        } catch (error) {
          lastError = error;
        }
      }
      throw lastError || new Error('Unable to fetch URL');
    }

    function enhanceAbstractWithGistLinks(container) {
      if (!container) return;

      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
      const textNodes = [];
      while (walker.nextNode()) {
        textNodes.push(walker.currentNode);
      }

      textNodes.forEach(node => convertTextNodeGistLinks(node));

      container.querySelectorAll('a[href]').forEach(anchor => {
        const href = anchor.getAttribute('href');
        if (isGistUrl(href)) {
          attachGistLinkBehavior(anchor, href);
        }
      });
    }

    function convertTextNodeGistLinks(node) {
      if (!node || !node.nodeValue || !node.nodeValue.includes('http')) return;
      const text = node.nodeValue;
      const regex = /(https?:\/\/[^\s<]+)/gi;
      const matches = [];
      let match;
      while ((match = regex.exec(text)) !== null) {
        if (isGistUrl(match[0])) {
          matches.push({ url: match[0], index: match.index });
        }
      }
      if (!matches.length) return;

      const fragment = document.createDocumentFragment();
      let cursor = 0;
      matches.forEach(({ url, index }) => {
        if (index > cursor) {
          fragment.appendChild(document.createTextNode(text.slice(cursor, index)));
        }
        fragment.appendChild(createGistLinkAnchor(url));
        cursor = index + url.length;
      });
      if (cursor < text.length) {
        fragment.appendChild(document.createTextNode(text.slice(cursor)));
      }
      node.parentNode.replaceChild(fragment, node);
    }

    function createGistLinkAnchor(url) {
      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.textContent = url;
      anchor.target = '_blank';
      anchor.rel = 'noopener noreferrer';
      attachGistLinkBehavior(anchor, url);
      return anchor;
    }

    function attachGistLinkBehavior(anchor, url) {
      if (!anchor || anchor.dataset.gistLinkBound === 'true') return;
      anchor.dataset.gistLinkBound = 'true';
      anchor.classList.add('blockscape-gist-link');
      anchor.title = 'Load this Gist into Blockscape';
      anchor.addEventListener('click', (event) => handleGistLinkClick(event, url, anchor));
    }

    async function handleGistLinkClick(event, url, anchor) {
      event.preventDefault();
      event.stopPropagation();
      if (!url || anchor.dataset.loading === 'true') return;
      anchor.dataset.loading = 'true';
      anchor.classList.add('is-loading');
      try {
        await loadFromUrl(url);
      } finally {
        anchor.dataset.loading = 'false';
        anchor.classList.remove('is-loading');
      }
    }

    function isGistUrl(candidate) {
      if (typeof candidate !== 'string') return false;
      try {
        const parsed = new URL(candidate, window.location.href);
        const host = parsed.hostname.toLowerCase();
        return host === 'gist.githubusercontent.com'
          || (host.startsWith('gist.') && host.endsWith('githubusercontent.com'));
      } catch {
        return false;
      }
    }

    // Load JSON from custom URL
    async function loadFromUrl(url) {
      try {
        console.log("[Blockscape] loading from URL:", url);
        const text = await fetchTextWithCacheBypass(url);
        const rawName = url.split('/').pop() || '';
        const baseName = rawName.replace(/\.[^.]+$/, '') || 'URL Model';
        let entries;
        try {
          entries = normalizeToModelsFromText(text, baseName);
        } catch (parseError) {
          throw new Error(`Invalid JSON payload: ${parseError.message}`);
        }
        if (!entries.length) {
          throw new Error('No JSON objects found in response.');
        }
        models.push(...entries.map((entry, idx) => {
          const dataTitle = (entry.data?.title ?? '').toString().trim();
          const fallbackTitle = entries.length > 1 ? `${baseName} #${idx + 1}` : baseName;
          return {
            ...entry,
            title: dataTitle || fallbackTitle
          };
        }));
        console.log(`[Blockscape] loaded ${entries.length} model(s) from URL:`, baseName);
        if (activeIndex === -1) {
          setActive(0);
        } else {
          renderModelList();
        }
        return true;
      } catch (error) {
        console.error("[Blockscape] URL load error:", error);
        alert(`Failed to load JSON from URL: ${error.message}`);
        return false;
      }
    }

    // Bootstrap with Blockscape
    (async function bootstrap() {
      const seedObj = JSON.parse(document.getElementById('seed').innerHTML.trim());
      ensureModelMetadata(seedObj, { titleHint: seedObj.title || 'Blockscape', idHint: seedObj.id || 'blockscape' });
      
      models.push({ id: uid(), title: seedObj.title || "Blockscape", data: seedObj });
      
      // Try to load JSON files from same directory
      await loadJsonFiles();
      
      const editorIndex = consumeEditorPayload();
      const shareIndex = consumeShareLink();
      const initialIndex = typeof shareIndex === 'number'
        ? shareIndex
        : (typeof editorIndex === 'number' ? editorIndex : 0);
      setActive(initialIndex);
    })();
  </script>
</body>

</html>
