<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Blockscape — simple landscape-style tiles</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <style>
    :root {
      color-scheme: light;
      --space-2xs: 0.2rem;
      --space-xs: 0.35rem;
      --space-sm: 0.5rem;
      --space-md: 0.75rem;
      --space-lg: 1.25rem;
      --space-xl: 2rem;
      --space-2xl: 3rem;

      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 16px;

      --font-text: "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;
      --font-mono: "JetBrains Mono", "Fira Code", monospace;
      --font-size-xs: 0.75rem;
      --font-size-sm: 0.875rem;
      --font-size-md: 1rem;
      --font-size-lg: 1.2rem;
      --font-weight-regular: 400;
      --font-weight-medium: 500;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;

      --color-text: #1f2937;
      --color-muted: #6b7280;
      --color-border: #d8dde8;
      --color-border-strong: #c3cad7;
      --color-surface: #ffffff;
      --color-surface-muted: #f4f6fb;
      --color-surface-subtle: #eef2f8;
      --color-shadow: 0 18px 36px -22px rgba(15, 23, 42, 0.45);

      --color-primary: #2563eb;
      --color-primary-soft: #e3edff;
      --color-danger: #dc2626;
      --color-danger-soft: #fde4e2;
      --color-warning: #f97316;
      --color-warning-soft: #ffe8d6;
      --color-accent: #0ea5e9;
      --color-external: #94a3b8;

      --transition: 160ms ease;

      --blockscape-tile: 6.5rem;
      --blockscape-gap: var(--space-md);
      --blockscape-radius: var(--radius-lg);
      --blockscape-foreground: var(--color-text);
      --blockscape-muted: var(--color-muted);
      --blockscape-border: var(--color-border);
      --blockscape-surface: var(--color-surface);
      --blockscape-surface-alt: var(--color-surface-muted);
      --blockscape-dep: var(--color-primary);
      --blockscape-revdep: #ef4444;
      --blockscape-reused: var(--color-warning);
      --blockscape-external: var(--color-external);
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: var(--color-surface-subtle);
      color: var(--color-text);
      font-family: var(--font-text);
      -webkit-font-smoothing: antialiased;
    }

    a {
      color: inherit;
    }

    .pf-v5-c-page {
      min-height: 100%;
      display: flex;
      flex-direction: column;
    }

    .pf-v5-c-page__header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: var(--color-surface);
      box-shadow: 0 1px 0 var(--color-border);
    }

    .blockscape-masthead {
      border-bottom: none;
    }

    .blockscape-toolbar {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: var(--space-md);
      padding: var(--space-sm) var(--space-lg);
      width: min(1180px, 100%);
      margin: 0 auto;
    }

    .blockscape-brand {
      display: inline-flex;
      align-items: center;
      gap: var(--space-sm);
      font-weight: var(--font-weight-bold);
      font-size: var(--font-size-lg);
      letter-spacing: 0.04em;
      text-transform: uppercase;
      margin-right: var(--space-sm);
    }

    .blockscape-brand h1 {
      font: inherit;
      margin: 0;
    }

    .blockscape-brand__logo {
      display: block;
      height: 52px;
      width: auto;
      max-width: 320px;
    }

    .blockscape-toolbar__controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: var(--space-sm);
      flex: 1 1 auto;
      min-width: 280px;
    }

    .blockscape-url-form {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin: 0;
    }

    .url-hint {
      min-height: 1.2rem;
      font-size: var(--font-size-xs);
      color: var(--color-muted);
      margin-left: 0.1rem;
    }

    .apicurio-controls {
      display: flex;
      flex-direction: column;
      gap: var(--space-2xs);
      min-width: 18rem;
    }

    .apicurio-subnote {
      margin-top: -0.25rem;
    }

    .apicurio-toggle {
      display: inline-flex;
      align-items: center;
      gap: var(--space-sm);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
    }

    .apicurio-toggle input {
      width: 1.2rem;
      height: 1.2rem;
    }

    .apicurio-artifacts {
      border: 1px dashed var(--color-border);
      border-radius: var(--radius-md);
      padding: var(--space-sm);
      background: var(--color-surface-muted);
      min-height: 3rem;
      font-size: var(--font-size-sm);
    }

    .apicurio-artifact-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: var(--space-2xs);
    }

    .apicurio-artifact {
      width: 100%;
      border: 1px solid var(--color-border);
      border-radius: var(--radius-sm);
      background: var(--color-surface);
      padding: var(--space-xs);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      text-align: left;
      gap: var(--space-2xs);
      cursor: pointer;
      font-size: var(--font-size-sm);
      transition: border-color var(--transition), background var(--transition), box-shadow var(--transition);
    }

    .apicurio-artifact:hover,
    .apicurio-artifact:focus-visible {
      border-color: var(--color-primary);
      background: var(--color-primary-soft);
      outline: none;
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.2);
    }

    .apicurio-artifact-title {
      font-weight: var(--font-weight-semibold);
    }

    .apicurio-artifact-meta {
      font-size: var(--font-size-xs);
      color: var(--color-muted);
    }

    .apicurio-version-list {
      margin-top: var(--space-xs);
      display: flex;
      flex-direction: column;
      gap: var(--space-2xs);
    }

    .apicurio-version-button {
      border: 1px dashed var(--color-border);
      border-radius: var(--radius-sm);
      padding: var(--space-2xs) var(--space-xs);
      background: var(--color-surface);
      font-size: var(--font-size-xs);
      cursor: pointer;
      text-align: left;
    }

    .apicurio-version-button:hover,
    .apicurio-version-button:focus-visible {
      border-color: var(--color-primary);
      background: var(--color-primary-soft);
      outline: none;
    }

    .apicurio-settings {
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      padding: var(--space-2xs) var(--space-sm) var(--space-xs);
      background: var(--color-surface);
      font-size: var(--font-size-xs);
    }

    .apicurio-settings summary {
      cursor: pointer;
      font-weight: var(--font-weight-semibold);
      list-style: none;
      display: flex;
      align-items: center;
      gap: var(--space-2xs);
    }

    .apicurio-settings summary::marker,
    .apicurio-settings summary::-webkit-details-marker {
      display: none;
    }

    .apicurio-fields {
      display: grid;
      gap: var(--space-xs);
      grid-template-columns: repeat(auto-fit, minmax(12rem, 1fr));
      margin-top: var(--space-xs);
    }

    .apicurio-fields label {
      display: flex;
      flex-direction: column;
      gap: var(--space-2xs);
    }

    .apicurio-fields input {
      font-size: var(--font-size-xs);
      padding: var(--space-2xs) var(--space-xs);
      border-radius: var(--radius-sm);
      border: 1px solid var(--color-border);
      background: var(--color-surface);
      color: inherit;
    }

    .apicurio-hint {
      margin: var(--space-xs) 0 0;
      color: var(--color-muted);
      font-size: var(--font-size-xs);
    }

    .apicurio-status {
      font-size: var(--font-size-xs);
      min-height: 1rem;
      color: var(--color-muted);
    }

    .apicurio-status.is-error {
      color: var(--color-danger);
    }

    .apicurio-status.is-success {
      color: var(--color-accent);
    }

    .blockscape-toolbar__controls .pf-v5-c-form-control {
      min-width: 11rem;
    }

    .blockscape-toolbar__controls .pf-v5-c-form-control.is-url {
      min-width: 14rem;
    }

    .blockscape-file {
      position: relative;
    }

    .blockscape-file input[type="file"] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .pf-v5-c-button {
      appearance: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-xs);
      border-radius: 999px;
      border: 1px solid transparent;
      padding: 0.4rem 0.95rem;
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-semibold);
      line-height: 1;
      cursor: pointer;
      transition: background var(--transition), border-color var(--transition), color var(--transition), box-shadow var(--transition);
      background: transparent;
      color: var(--blockscape-foreground);
    }

    .pf-v5-c-button:hover {
      box-shadow: 0 8px 18px -12px rgba(15, 23, 42, 0.4);
    }

    .pf-v5-c-button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.25);
    }

    .pf-v5-c-button.pf-m-primary {
      background: var(--color-primary);
      border-color: var(--color-primary);
      color: #fff;
    }

    .pf-v5-c-button.pf-m-primary:hover {
      background: #1d4fd7;
      border-color: #1d4fd7;
    }

    .pf-v5-c-button.pf-m-secondary {
      background: var(--color-surface-muted);
      border-color: var(--color-border-strong);
      color: var(--blockscape-foreground);
    }

    .pf-v5-c-button.pf-m-secondary:hover {
      background: #e5e9f4;
    }

    .pf-v5-c-button.pf-m-tertiary {
      background: transparent;
      border-color: var(--color-border);
      color: var(--color-muted);
    }

    .pf-v5-c-button.pf-m-tertiary:hover {
      color: var(--blockscape-foreground);
      border-color: var(--color-border-strong);
      background: var(--color-surface-muted);
    }

    .pf-v5-c-button.pf-m-plain {
      border: none;
      padding: 0.35rem;
      color: var(--color-muted);
      border-radius: 50%;
    }

    .pf-v5-c-button.pf-m-plain:hover {
      background: var(--color-surface-muted);
      color: var(--blockscape-foreground);
      box-shadow: none;
    }

    .pf-v5-c-form-control {
      height: 2.5rem;
      padding: 0 0.85rem;
      border-radius: 999px;
      border: 1px solid var(--color-border);
      background: var(--color-surface);
      font-family: inherit;
      font-size: var(--font-size-sm);
      color: inherit;
      transition: border-color var(--transition), box-shadow var(--transition);
    }

    .pf-v5-c-form-control::placeholder {
      color: var(--color-muted);
      opacity: 0.75;
    }

    .pf-v5-c-form-control:focus-visible {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
    }

    .blockscape-legend {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: var(--space-md);
      font-size: var(--font-size-xs);
      color: var(--blockscape-muted);
      font-weight: var(--font-weight-medium);
      flex-wrap: wrap;
    }

    .legend-entry {
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
      white-space: nowrap;
    }

    .legend-dot {
      width: 0.65rem;
      height: 0.65rem;
      border-radius: 50%;
      border: 1px solid var(--blockscape-border);
    }

    .legend-dot--dep {
      background: var(--color-primary-soft);
      border-color: var(--blockscape-dep);
    }

    .legend-dot--revdep {
      background: var(--color-danger-soft);
      border-color: var(--blockscape-revdep);
    }

    .legend-dot--reused {
      background: var(--color-warning-soft);
      border-color: var(--blockscape-reused);
    }

    .legend-dot--external {
      background: #edf1f7;
      border-color: var(--blockscape-external);
    }

    .pf-v5-c-page__main {
      flex: 1 1 auto;
    }

    .blockscape-content {
      display: flex;
      gap: var(--space-lg);
      width: min(1180px, calc(100% - 2 * var(--space-lg)));
      margin: 0 auto;
      padding: var(--space-lg) 0 var(--space-xl);
      align-items: flex-start;
    }

    .blockscape-sidebar {
      flex: 0 0 240px;
      background: var(--blockscape-surface);
      border: 1px solid var(--blockscape-border);
      border-radius: var(--radius-md);
      padding: var(--space-md);
      box-shadow: var(--color-shadow);
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .sidebar-heading {
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--blockscape-muted);
    }

    .model-nav-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }

    .model-nav-list li {
      margin: 0;
      padding: 0;
    }

    .model-nav-button {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      text-align: left;
      gap: var(--space-2xs);
      border: 1px solid transparent;
      border-radius: var(--radius-sm);
      background: transparent;
      color: var(--color-text);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      padding: var(--space-sm);
      cursor: pointer;
      transition: background var(--transition), border-color var(--transition), color var(--transition);
    }

    .model-nav-button:hover,
    .model-nav-button:focus-visible {
      outline: none;
      border-color: var(--color-border);
      background: var(--color-surface-muted);
    }

    .model-nav-button.is-active {
      border-color: var(--color-primary);
      background: var(--color-primary-soft);
      color: var(--color-primary);
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.1);
    }

    .model-nav-label {
      font-weight: var(--font-weight-semibold);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: var(--space-2xs);
    }

    .model-nav-title {
      font-size: var(--font-size-sm);
    }

    .model-nav-id {
      font-size: var(--font-size-xs);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--blockscape-muted);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-sm);
      padding: 0 var(--space-2xs);
      background: var(--color-surface-muted);
    }

    .model-nav-meta {
      font-size: var(--font-size-xs);
      color: var(--blockscape-muted);
    }

    .model-nav-empty {
      font-size: var(--font-size-xs);
      color: var(--blockscape-muted);
    }

    .model-actions {
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }

    .model-actions .pf-v5-c-button {
      width: 100%;
    }

    .blockscape-main {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
    }

    .blockscape-json-panel,
    .blockscape-main-section {
      width: 100%;
      margin: 0;
    }

    .blockscape-json-panel {
      padding: 0;
      border: none;
      background: transparent;
      box-shadow: none;
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
    }

    .blockscape-json-panel__title {
      font-weight: var(--font-weight-semibold);
      font-size: var(--font-size-sm);
      margin: 0;
    }

    .blockscape-json-panel .muted {
      font-size: var(--font-size-xs);
      margin: 0;
      line-height: 1.4;
    }

    .blockscape-json-controls {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-md);
      align-items: flex-start;
    }

    .blockscape-json-controls textarea {
      flex: 1 1 22rem;
      min-height: 12rem;
      font-family: var(--font-mono);
      font-size: var(--font-size-sm);
      border-radius: var(--radius-md);
      border: 1px solid var(--color-border);
      padding: var(--space-sm) var(--space-md);
      background: var(--color-surface-muted);
      color: var(--blockscape-foreground);
      resize: vertical;
      transition: border-color var(--transition), box-shadow var(--transition);
    }

    .blockscape-json-controls textarea:focus-visible {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
      background: var(--color-surface);
    }

    .blockscape-json-actions {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      min-width: 12rem;
    }

    .blockscape-main-section {
      padding: 0 var(--space-lg) var(--space-xl);
    }

    .blockscape-model-meta {
      margin-bottom: var(--space-md);
      display: flex;
      flex-direction: column;
      gap: var(--space-2xs);
    }

    .version-nav {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-sm) var(--space-md);
      margin-bottom: var(--space-md);
      background: var(--color-surface);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      box-shadow: var(--color-shadow);
      flex-wrap: wrap;
    }

    .version-nav__title {
      font-weight: var(--font-weight-semibold);
      color: var(--color-text);
    }

    .version-nav__status {
      font-size: var(--font-size-xs);
      color: var(--color-muted);
    }

    .version-nav__controls {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2xs);
      margin-left: auto;
    }

    .version-nav__button {
      border: 1px solid var(--color-border);
      background: var(--color-surface-muted);
      color: var(--color-text);
      font-size: var(--font-size-xs);
      padding: var(--space-2xs) var(--space-sm);
      border-radius: var(--radius-sm);
      cursor: pointer;
    }

    .version-nav__button:hover,
    .version-nav__button:focus-visible {
      background: var(--color-primary-soft);
      border-color: var(--color-primary);
      outline: none;
    }

    .blockscape-model-title {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text);
    }

    .blockscape-model-id {
      font-size: var(--font-size-xs);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--blockscape-muted);
    }

    .blockscape-tabs {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      margin-top: var(--space-md);
    }

    .blockscape-tablist {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2xs);
      border-bottom: 1px solid var(--color-border);
    }

    .blockscape-tab {
      appearance: none;
      border: 1px solid transparent;
      border-bottom: none;
      border-radius: var(--radius-md) var(--radius-md) 0 0;
      background: transparent;
      padding: var(--space-sm) var(--space-md);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-semibold);
      color: var(--blockscape-muted);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: var(--space-2xs);
      min-width: 6rem;
      transition: color var(--transition), background var(--transition), border-color var(--transition);
    }

    .blockscape-tab.is-active {
      color: var(--color-text);
      background: var(--color-surface);
      border-color: var(--color-border);
      box-shadow: var(--color-shadow);
      position: relative;
      top: 1px;
    }

    .blockscape-tabpanels {
      border: 1px solid var(--color-border);
      border-radius: var(--radius-lg);
      background: var(--color-surface);
      box-shadow: var(--color-shadow);
    }

    .blockscape-tabpanel {
      display: none;
      padding: var(--space-lg);
    }

    .blockscape-tabpanel.is-active {
      display: block;
    }

    .blockscape-registry-panel {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
      padding: var(--space-lg);
      background: var(--blockscape-surface);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      box-shadow: var(--color-shadow);
    }

    .blockscape-registry-header {
      display: flex;
      flex-direction: column;
      gap: var(--space-2xs);
    }

    .blockscape-registry-header h2 {
      margin: 0;
      font-size: var(--font-size-md);
    }

    .blockscape-registry-header p {
      margin: 0;
      font-size: var(--font-size-sm);
      color: var(--color-muted);
    }

    .blockscape-source-panel {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .blockscape-abstract {
      font-size: var(--font-size-sm);
      color: var(--blockscape-muted);
      line-height: 1.5;
      padding: var(--space-md);
      background: var(--blockscape-surface-alt);
      border-radius: var(--radius-md);
      border-left: 3px solid var(--blockscape-dep);
      margin: 0;
      box-shadow: var(--color-shadow);
    }

    .blockscape-abstract-panel {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .blockscape-abstract-placeholder {
      border: 1px dashed var(--color-border);
      border-radius: var(--radius-md);
      padding: var(--space-lg);
      background: var(--color-surface-muted);
      color: var(--blockscape-muted);
      font-size: var(--font-size-sm);
    }

    .blockscape-abstract a.blockscape-gist-link {
      color: var(--color-primary);
      font-weight: var(--font-weight-semibold);
      text-decoration: underline;
      cursor: pointer;
      word-break: break-all;
    }

    .blockscape-abstract a.blockscape-gist-link.is-loading {
      opacity: 0.65;
      pointer-events: none;
    }

    .category {
      margin: var(--space-lg) 0;
    }

    .blockscape-render {
      position: relative;
    }

    .blockscape-tab-tooltip {
      position: absolute;
      max-width: min(420px, calc(100% - 2 * var(--space-md)));
      padding: var(--space-md);
      background: var(--color-surface);
      box-shadow: var(--color-shadow);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      font-size: var(--font-size-sm);
      color: var(--blockscape-muted);
      z-index: 1000;
      pointer-events: none;
      transition: opacity var(--transition);
      opacity: 0;
    }

    .blockscape-tab-tooltip.is-visible {
      opacity: 1;
    }

    .cat-head {
      display: inline-flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-sm);
    }

    .cat-title {
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--blockscape-muted);
    }

    .cat-count {
      font-size: var(--font-size-xs);
      color: var(--color-muted);
    }

    .grid {
      position: relative;
      display: grid;
      grid-auto-rows: var(--blockscape-tile);
      grid-template-columns: repeat(auto-fill, minmax(var(--blockscape-tile), 1fr));
      gap: var(--blockscape-gap);
      padding: var(--blockscape-gap) 0;
      border-top: 1px dashed var(--blockscape-border);
    }

    .tile {
      position: relative;
      background: var(--blockscape-surface);
      border: 1px solid var(--blockscape-border);
      border-radius: var(--blockscape-radius);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      cursor: grab;
      transition: box-shadow var(--transition), transform var(--transition), border-color var(--transition);
      box-shadow: var(--color-shadow);
    }

    .tile:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 30px -24px rgba(15, 23, 42, 0.55);
    }

    .tile:active {
      transform: translateY(1px);
    }

    .tile.dragging {
      opacity: 0.5;
      cursor: grabbing;
      transform: rotate(4deg);
    }

    .tile.drag-over {
      border-color: var(--blockscape-dep);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
    }

    .grid.drag-active {
      background: var(--color-primary-soft);
    }

    .logo {
      width: 44px;
      height: 44px;
      object-fit: contain;
      opacity: .95;
    }

    .name {
      font-size: var(--font-size-xs);
      text-align: center;
      line-height: 1.15;
      padding: 0 var(--space-sm) var(--space-xs);
    }

    .badge {
      position: absolute;
      top: var(--space-sm);
      right: var(--space-sm);
      font-size: var(--font-size-xs);
      background: var(--color-warning-soft);
      color: var(--blockscape-reused);
      border: 1px solid var(--color-warning);
      border-radius: 999px;
      padding: 0.1rem 0.45rem;
      display: none;
      font-weight: var(--font-weight-medium);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .tile.reused .badge {
      display: inline-block;
    }

    .tile.external {
      border-style: dashed;
      border-color: var(--color-external);
      color: var(--blockscape-muted);
      background: #f8fafc;
    }

    .tile .external-link {
      position: absolute;
      top: var(--space-sm);
      left: var(--space-sm);
      width: 24px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: rgba(148, 163, 184, 0.16);
      color: inherit;
      font-size: 0.75rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
      transition: background var(--transition), color var(--transition), border var(--transition);
    }

    .tile .external-link:hover,
    .tile .external-link:focus-visible {
      background: rgba(148, 163, 184, 0.28);
      border-color: rgba(148, 163, 184, 0.45);
      color: var(--color-text);
    }

    .tile.dep {
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
      border-color: var(--blockscape-dep);
    }

    .tile.revdep {
      box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
      border-color: var(--blockscape-revdep);
    }

    .tile.selected {
      outline: 3px solid rgba(15, 23, 42, 0.25);
      outline-offset: 2px;
    }

    .muted {
      color: var(--blockscape-muted);
    }

    .svg-layer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .item-preview {
      --item-preview-width: min(420px, calc(100vw - 2 * var(--space-md)));
      --item-preview-height: min(70vh, calc(100vh - 2 * var(--space-md)));
      position: fixed;
      display: flex;
      flex-direction: column;
      width: var(--item-preview-width);
      max-height: var(--item-preview-height);
      background: var(--blockscape-surface);
      border: 1px solid var(--blockscape-border);
      border-radius: var(--radius-md);
      box-shadow: var(--color-shadow);
      opacity: 0;
      transform: translateY(4px);
      pointer-events: none;
      transition: opacity var(--transition), transform var(--transition);
      z-index: 999;
    }

    .item-preview--expanded {
      --item-preview-width: min(630px, calc(100vw - 2 * var(--space-md)));
      --item-preview-height: min(calc(100vh - 2 * var(--space-md)), 1200px);
    }

    .item-preview.is-visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .item-preview__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-xs);
      padding: var(--space-xs) var(--space-sm);
      border-bottom: 1px solid var(--color-border);
      background: var(--color-surface-muted);
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold);
    }

    .item-preview__title {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1 1 auto;
    }

    .item-preview__actions {
      display: flex;
      gap: var(--space-2xs);
      align-items: center;
      flex: 0 0 auto;
    }

    .item-preview__action {
      border: 1px solid var(--color-border);
      background: var(--color-surface);
      color: var(--blockscape-foreground);
      font-size: var(--font-size-xs);
      padding: var(--space-2xs) var(--space-sm);
      border-radius: var(--radius-sm);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
    }

    .item-preview__action:hover,
    .item-preview__action:focus-visible {
      background: var(--color-surface-muted);
      border-color: var(--color-border-strong);
    }

    .item-preview__close {
      border: none;
      background: transparent;
      color: var(--color-muted);
      cursor: pointer;
      font-size: 1.25rem;
      line-height: 1;
      border-radius: var(--radius-sm);
      padding: 0 var(--space-2xs);
    }

    .item-preview__close:hover,
    .item-preview__close:focus-visible {
      color: var(--blockscape-foreground);
      background: var(--color-surface-muted);
      outline: none;
    }

    .item-preview__body {
      flex: 1 1 auto;
      overflow: auto;
      padding: var(--space-sm);
      background: var(--blockscape-surface);
      font-size: var(--font-size-xs);
      line-height: 1.4;
    }

    .item-preview__frame {
      width: 100%;
      height: 100%;
      border: none;
      display: block;
    }

    .item-preview--has-frame .item-preview__body {
      padding: 0;
    }

    .item-preview__status {
      color: var(--color-muted);
    }

    @media (max-width: 1024px) {
      .blockscape-toolbar {
        padding: var(--space-sm) var(--space-md);
        gap: var(--space-sm);
      }

      .blockscape-content {
        flex-direction: column;
        gap: var(--space-md);
        width: calc(100% - 2 * var(--space-md));
        padding: var(--space-md) 0 var(--space-lg);
      }

      .blockscape-sidebar {
        width: 100%;
      }
    }

    @media (max-width: 720px) {
      .blockscape-toolbar {
        flex-direction: column;
        align-items: stretch;
      }

      .blockscape-content {
        width: calc(100% - 2 * var(--space-sm));
        gap: var(--space-sm);
      }

      .blockscape-brand {
        justify-content: space-between;
        width: 100%;
      }

      .blockscape-brand__logo {
        height: 44px;
      }

      .blockscape-toolbar__controls {
        width: 100%;
      }

      .blockscape-toolbar__controls .pf-v5-c-form-control,
      .blockscape-toolbar__controls .pf-v5-c-button {
        flex: 1 1 auto;
      }

      .apicurio-controls {
        min-width: auto;
      }

      .blockscape-legend {
        width: 100%;
        justify-content: flex-start;
        margin-left: 0;
      }

      .blockscape-json-actions {
        width: 100%;
        flex-direction: row;
        justify-content: flex-start;
      }
    }
  </style>
</head>

<body>
  <div class="pf-v5-c-page">
    <header class="pf-v5-c-page__header">
      <div class="pf-v5-c-masthead pf-m-display-inline blockscape-masthead">
        <div class="pf-v5-c-masthead__content">
          <div class="blockscape-toolbar">
            <div class="blockscape-brand">
              <h1 class="sr-only">Blockscape</h1>
              <img class="blockscape-brand__logo" src="logos/blockscape-logo.svg"
                alt="Blockscape — landscape tile explorer" decoding="async" />
              <a href="https://github.com/pwright/blockscape" target="_blank"
                class="pf-v5-c-button pf-m-plain" title="View on GitHub" aria-label="View Blockscape on GitHub">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                  <path
                    d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
                </svg>
              </a>
            </div>
            <div class="blockscape-toolbar__controls">
              <label class="sr-only" for="search">Search tiles</label>
              <input id="search" class="pf-v5-c-form-control" type="text" placeholder="Search…" />
               
              <form id="urlForm" class="blockscape-url-form" autocomplete="on" novalidate>
                <label class="sr-only" for="urlInput">Load JSON from URL</label>
                <input id="urlInput" name="modelUrl" class="pf-v5-c-form-control is-url" type="url"
                  placeholder="Load JSON from URL…" autocomplete="additional-name" />
                <button id="loadUrl" class="pf-v5-c-button pf-m-secondary" type="submit">Load URL</button>
                <div id="urlHint" class="url-hint" aria-live="polite"></div>
              </form>
              
 
              <label class="pf-v5-c-button pf-m-secondary blockscape-file" role="button">
                <span>Load File(s)</span>
                <input id="file" type="file" accept=".bs,.json,.txt" multiple />
              </label>
 
              <button id="openInEditor" class="pf-v5-c-button pf-m-primary" type="button" title="Open current JSON in the editor">Edit</button>
              
              <button id="shareModel" class="pf-v5-c-button pf-m-primary" type="button" title="Copy a shareable URL for this model">Share</button>
            </div>
            <div class="blockscape-legend" role="presentation">
              <span class="legend-entry"><span class="legend-dot legend-dot--dep"></span> enables</span>
              <span class="legend-entry"><span class="legend-dot legend-dot--revdep"></span> dependents</span>
              <span class="legend-entry"><span class="legend-dot legend-dot--reused"></span> reused</span>
              <span class="legend-entry"><span class="legend-dot legend-dot--external"></span> external link</span>
            </div>
          </div>
        </div>
      </div>
    </header>

    <main class="pf-v5-c-page__main">
      <div class="blockscape-content">
        <aside class="blockscape-sidebar" aria-label="Models">
          <div class="sidebar-heading">Models</div>
          <ul id="modelList" class="model-nav-list"></ul>
          <div class="model-actions">
            <button id="removeModel" class="pf-v5-c-button pf-m-tertiary" type="button"
              title="Remove selected model">Remove active</button>
            <button id="clear" class="pf-v5-c-button pf-m-tertiary" type="button">Clear selection</button>
          </div>
        </aside>
        <div class="blockscape-main">
          <section class="pf-v5-c-page__main-section blockscape-json-panel" hidden
            aria-label="Model source JSON editor">
            <p class="blockscape-json-panel__title">Paste / edit JSON for the <b>active</b> model (schema below)</p>
            <div class="muted">
              Schema: <code>{ id, title, abstract?, categories:[{id,title,items:[{id,name,logo?,external?:url,color?,deps:[]}]}], links?:[{from,to}] }</code><br />
              You can paste multiple objects separated by <code>---</code> or <code>%%%</code> to append several models.
              A single object replaces only when you click “Replace active with JSON”. Tip: with no input focused, press
              Cmd/Ctrl+V anywhere on the page to append clipboard JSON instantly.
            </div>
            <div class="blockscape-json-controls">
              <textarea id="jsonBox" class="pf-v5-c-form-control"
                aria-label="JSON editor for the active model"></textarea>
              <div class="blockscape-json-actions">
                <button id="copyJson" class="pf-v5-c-button pf-m-tertiary" type="button"
                  title="Copy the current JSON to your clipboard">Copy</button>
                <button id="pasteJson" class="pf-v5-c-button pf-m-tertiary" type="button"
                  title="Paste clipboard JSON to replace the editor contents">Paste</button>
                <button id="appendFromBox" class="pf-v5-c-button pf-m-primary" type="button">Append model(s)</button>
                <button id="replaceActive" class="pf-v5-c-button pf-m-secondary" type="button">Replace active with
                  JSON</button>
              </div>
            </div>
          </section>

          <section class="pf-v5-c-page__main-section blockscape-main-section">
            <div id="app" aria-live="polite"></div>
          </section>
        </div>
      </div>
    </main>
  </div>

  <template id="seed">
{
  "id": "blockscape",
  "title": "Blockscape (AI maps)",
  "abstract": "Blockscape (pronounced BYK-shed) visualizes value chains and dependencies using a BS file. Inspired by Wardley maps, these maps emphasizes the Communication layer that makes maps comprehensible, alongside concrete user experiences, authoring & LLM flows, presentation semantics, and the platform services that enable them.",
  "categories": [
    {
      "id": "communication",
      "title": "Communication",
      "items": [
        { "id": "gestalt", "name": "Visual schema", "deps": [] },
        { "id": "value-chain", "name": "Value chain (y-axis)", "deps": [] },
        { "id": "spacial-memory", "name": "Spacial memory", "deps": [] },
        { "id": "evolution", "name": "Evolution (x-axis)", "deps": [] },
        { "id": "legend-literacy", "name": "Legend literacy", "deps": [] },
        { "id": "relational-awareness", "name": "Relational awareness", "deps": [] },
        { "id": "icons", "name": "Iconography", "deps": [] }
      ]
    },
    {
      "id": "experience",
      "title": "User Experience",
      "items": [
        { "id": "paste-bs-file", "name": "Paste BS File", "deps": ["bs-parser", "schema-validator"] },
        { "id": "load-multidoc-file", "name": "Load Multi-Document File", "deps": ["multidoc-assembler", "bs-parser", "schema-validator"] },
        { "id": "load-multidoc-from-url", "name": "Load Multi-Document from URL", "deps": ["url-fetcher", "multidoc-assembler", "bs-parser", "schema-validator"] },
        { "id": "create-gist-multidoc", "name": "Create Header+Detail in Gist", "deps": ["gist-integration", "multidoc-assembler", "schema-validator"] },
        { "id": "abstract-gist-loading", "name": "Abstract Supports Gist Loading", "deps": ["gist-integration", "bs-parser", "schema-validator"] }
      ]
    },
    {
      "id": "authoring-ai",
      "title": "Authoring and LLM",
      "items": [
        { "id": "bs-format-simple", "name": "BS format is simple", "deps": [] },
        { "id": "editor-human-terms", "name": "Editor (human terms)", "deps": ["gestalt"] },
        { "id": "llm-generate-bs", "name": "LLM generates BS", "deps": ["schema-validator"], "external": "https://github.com/pwright/blockscape/blob/main/map-generation-prompt.md" },
        { "id": "llm-consume-bs", "name": "LLM consumes BS", "deps": ["bs-parser"] }
      ]
    },
    {
      "id": "presentation",
      "title": "Presentation Semantics",
      "items": [
        { "id": "layout_engine", "name": "Layout Engine", "deps": ["bs-parser", "gestalt", "icons"] },
        { "id": "value_visibility_axis", "name": "Vertical Position = Visible Value", "deps": ["spacial-memory", "legend-literacy", "value-chain"] },
        { "id": "evolution_axis", "name": "Horizontal Evolution (Optional)", "deps": ["legend-literacy", "evolution"] }
      ]
    },
    {
      "id": "platform",
      "title": "Platform Services",
      "items": [
        { "id": "bs-parser", "name": "BS Parser", "deps": [] },
        { "id": "multidoc-assembler", "name": "Multi-Doc Assembler", "deps": [] },
        { "id": "gist-integration", "name": "Gist Integration", "deps": [] },
        { "id": "url-fetcher", "name": "URL Fetcher", "deps": [] },
        { "id": "schema-validator", "name": "Schema Validator", "deps": [] }
      ]
    }
  ]
}
  </template>

  <svg id="overlay" class="svg-layer"></svg>
  <div id="tabTooltip" class="blockscape-tab-tooltip" hidden aria-hidden="true"></div>

  <div id="itemPreview" class="item-preview" hidden aria-hidden="true">
    <div class="item-preview__header">
      <span class="item-preview__title">Preview</span>
      <div class="item-preview__actions" hidden></div>
      <button type="button" class="item-preview__close" aria-label="Close preview">&times;</button>
    </div>
    <div class="item-preview__body">
      <div class="item-preview__status">Right-click a tile to see related notes.</div>
    </div>
  </div>

  <script>
    console.log("[Blockscape] init");

    const jsonBox = document.getElementById('jsonBox');
    const jsonPanel = document.querySelector('.blockscape-json-panel');
    const app = document.getElementById('app');
    const overlay = document.getElementById('overlay');
    const tabTooltip = document.getElementById('tabTooltip');
    const modelList = document.getElementById('modelList');
    const preview = document.getElementById('itemPreview');
    const urlForm = document.getElementById('urlForm');
    const urlInput = document.getElementById('urlInput');
    const loadUrlButton = document.getElementById('loadUrl');
    let pushApicurioButton = null;
    let apicurioListButton = null;
    let apicurioUrlInput = null;
    let apicurioGroupInput = null;
    let apicurioTokenInput = null;
    let apicurioToggleInput = null;
    let apicurioSemverInput = null;
    let apicurioStatusNode = null;
    let apicurioArtifactsContainer = null;
    const previewTitle = preview.querySelector('.item-preview__title');
    const previewBody = preview.querySelector('.item-preview__body');
    const previewActions = preview.querySelector('.item-preview__actions');
    const previewClose = preview.querySelector('.item-preview__close');
    const downloadButton = document.getElementById('downloadJson');
    const shareButton = document.getElementById('shareModel');
    const editButton = document.getElementById('openInEditor');
    const copyJsonButton = document.getElementById('copyJson');
    const pasteJsonButton = document.getElementById('pasteJson');
    const EDITOR_TRANSFER_KEY = 'blockscape:editorPayload';
    const EDITOR_TRANSFER_MESSAGE_TYPE = 'blockscape:editorTransfer';
    const defaultDocumentTitle = document.title;
    const APICURIO_STORAGE_KEY = 'blockscape:apicurioConfig';
    const DEFAULT_APICURIO_BASE = 'http://localhost:8080/apis/registry/v3';
    const DEFAULT_APICURIO_GROUP = 'bs';
    const DEFAULT_APICURIO_ENABLED = false;
    const DEFAULT_APICURIO_SEMVER_ENABLED = false;

    // Show the seed in the editor initially.
    jsonBox.value = document.getElementById('seed').innerHTML.trim();

    // ===== State =====
    /** @type {{id:string,title:string,data:any}[]} */
    let models = [];
    let activeIndex = -1;
    let apicurioConfig = {
      baseUrl: DEFAULT_APICURIO_BASE,
      groupId: DEFAULT_APICURIO_GROUP,
      authToken: '',
      enabled: DEFAULT_APICURIO_ENABLED,
      useSemver: DEFAULT_APICURIO_SEMVER_ENABLED
    };

    let model = null;           // parsed result of active model: { m, fwd, rev, reusedLocal, seen }
    let index = new Map();      // id -> {el, catId, rect}
    let selection = null;
    let previewRequestId = 0;
    let previewAnchor = { x: 0, y: 0 };
    let lastDeletedItem = null;
    let apicurioArtifactsById = new Map();
    let apicurioArtifactVersions = new Map();

    hydrateApicurioConfig();

    // ===== Utilities =====
    function uid() { return Math.random().toString(36).slice(2, 10); }

    function base64Encode(text) {
      const bytes = new TextEncoder().encode(text);
      let binary = '';
      bytes.forEach(b => { binary += String.fromCharCode(b); });
      return btoa(binary);
    }

    function base64Decode(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return new TextDecoder().decode(bytes);
    }

    function base64UrlEncode(text) {
      return base64Encode(text).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
    }

    function base64UrlDecode(token) {
      let base64 = token.replace(/-/g, '+').replace(/_/g, '/');
      const pad = base64.length % 4;
      if (pad) base64 += '='.repeat(4 - pad);
      return base64Decode(base64);
    }

    function download(filename, text) {
      const blob = new Blob([text], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    async function writeTextToClipboard(text) {
      if (!navigator.clipboard?.writeText) return false;
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch (err) {
        console.warn('[Blockscape] clipboard write failed', err);
        return false;
      }
    }

    async function readTextFromClipboard() {
      if (!navigator.clipboard?.readText) {
        throw new Error('Clipboard read not supported');
      }
      return navigator.clipboard.readText();
    }

    function makeDownloadName(base) {
      return (base || 'blockscape')
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9._-]+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '') || 'blockscape';
    }

    function stableStringify(value) {
      if (value === null || typeof value !== 'object') return JSON.stringify(value);
      if (Array.isArray(value)) return `[${value.map(v => stableStringify(v)).join(',')}]`;
      const keys = Object.keys(value).sort();
      const parts = keys.map(k => `${JSON.stringify(k)}:${stableStringify(value[k])}`);
      return `{${parts.join(',')}}`;
    }

    function canonicalizeJson(value) {
      try {
        return stableStringify(value);
      } catch {
        return '';
      }
    }

    function computeJsonFingerprint(input) {
      try {
        const value = typeof input === 'string' ? JSON.parse(input) : input;
        const fp = canonicalizeJson(value);
        if (fp) return fp;
      } catch (err) {
        console.warn('[Blockscape] fingerprint parse failed (first pass)', err);
      }
      try {
        const clone = JSON.parse(JSON.stringify(input));
        const fp = canonicalizeJson(clone);
        if (fp) return fp;
      } catch (err) {
        console.warn('[Blockscape] fingerprint failed for value', err);
      }
      try {
        return JSON.stringify(input) || '';
      } catch {
        return '';
      }
    }

    function ensureModelMetadata(data, { titleHint = 'Untitled Model', idHint } = {}) {
      if (!data || typeof data !== 'object') return data;
      const trimmedTitle = (data.title ?? '').toString().trim();
      data.title = trimmedTitle || titleHint || 'Untitled Model';

      const trimmedId = (data.id ?? '').toString().trim();
      if (!trimmedId) {
        const base = idHint || data.title || titleHint || 'model';
        const slug = makeDownloadName(base).replace(/\./g, '-');
        data.id = slug || `model-${uid()}`;
      } else {
        data.id = trimmedId;
      }

      if (typeof data.abstract !== 'string') {
        data.abstract = data.abstract == null ? '' : String(data.abstract);
      }
      return data;
    }

    function getModelTitle(entry, fallback = 'Untitled Model') {
      if (!entry) return fallback;
      const candidate = (entry.data?.title ?? entry.title ?? '').toString().trim();
      return candidate || fallback;
    }

    function getModelId(entry) {
      const candidate = entry?.data?.id;
      if (!candidate) return null;
      const trimmed = candidate.toString().trim();
      return trimmed || null;
    }

    function sanitizeApicurioBaseUrl(value) {
      const trimmed = (value || '').toString().trim();
      return trimmed.replace(/\/+$/, '');
    }

    function hydrateApicurioConfig() {
      let restored = {};
      if (window?.localStorage) {
        try {
          const raw = localStorage.getItem(APICURIO_STORAGE_KEY);
          if (raw) {
            const parsed = JSON.parse(raw);
            if (parsed && typeof parsed === 'object') {
              restored = parsed;
            }
          }
        } catch (err) {
          console.warn('[Blockscape] failed to restore Apicurio settings', err);
        }
      }
      const restoredBase = sanitizeApicurioBaseUrl(restored.baseUrl ?? DEFAULT_APICURIO_BASE);
      const restoredGroup = (restored.groupId ?? DEFAULT_APICURIO_GROUP).toString().trim();
      let restoredEnabled = DEFAULT_APICURIO_ENABLED;
      let restoredSemver = DEFAULT_APICURIO_SEMVER_ENABLED;
      if (typeof restored.enabled === 'boolean') {
        restoredEnabled = restored.enabled;
      } else if (typeof restored.enabled === 'string') {
        restoredEnabled = restored.enabled === 'true';
      }
      if (typeof restored.useSemver === 'boolean') {
        restoredSemver = restored.useSemver;
      } else if (typeof restored.useSemver === 'string') {
        restoredSemver = restored.useSemver === 'true';
      }
      apicurioConfig.baseUrl = restoredBase || DEFAULT_APICURIO_BASE;
      apicurioConfig.groupId = restoredGroup || DEFAULT_APICURIO_GROUP;
      apicurioConfig.authToken = (restored.authToken ?? '').toString().trim();
      apicurioConfig.enabled = restoredEnabled;
      apicurioConfig.useSemver = restoredSemver;
      refreshApicurioUiState();
    }

    function syncApicurioInputsFromConfig() {
      if (apicurioUrlInput) apicurioUrlInput.value = apicurioConfig.baseUrl || '';
      if (apicurioGroupInput) apicurioGroupInput.value = apicurioConfig.groupId || '';
      if (apicurioTokenInput) apicurioTokenInput.value = apicurioConfig.authToken || '';
      if (apicurioToggleInput) apicurioToggleInput.checked = isApicurioEnabled();
      if (apicurioSemverInput) apicurioSemverInput.checked = Boolean(apicurioConfig.useSemver);
    }

    function refreshApicurioUiState() {
      syncApicurioInputsFromConfig();
      if (!isApicurioEnabled()) {
        setApicurioStatus('Apicurio integration is off. Enable it to allow pushes.', 'muted');
        resetApicurioArtifactsPanel('Apicurio integration is disabled.');
      } else if (!hasApicurioDetails()) {
        setApicurioStatus('Enter Apicurio connection details to enable push.', 'muted');
        resetApicurioArtifactsPanel('Enter registry details to browse artifacts.');
      } else {
        setApicurioStatus('Apicurio push is ready when a model is selected.', 'muted');
        if (!apicurioArtifactsById.size) {
          setApicurioArtifactsMessage('Click “List artifacts” to browse the current group.');
        }
      }
      updateApicurioAvailability();
    }

    function resetApicurioArtifactsPanel(message) {
      apicurioArtifactsById.clear();
      setApicurioArtifactsMessage(message);
    }

    function setApicurioArtifactsMessage(message) {
      if (!apicurioArtifactsContainer) return;
      apicurioArtifactsContainer.innerHTML = '';
      if (!message) return;
      const p = document.createElement('p');
      p.className = 'apicurio-hint';
      p.textContent = message;
      apicurioArtifactsContainer.appendChild(p);
    }

    function renderApicurioArtifactsList(entries) {
      if (!apicurioArtifactsContainer) return;
      apicurioArtifactsContainer.innerHTML = '';
      if (!entries.length) {
        setApicurioArtifactsMessage('No artifacts found in this group.');
        return;
      }
      const list = document.createElement('ul');
      list.className = 'apicurio-artifact-list';
      entries.forEach(entry => {
        if (!entry?.artifactId) return;
        const li = document.createElement('li');
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'apicurio-artifact';
        button.dataset.artifactId = entry.artifactId;
        button.dataset.artifactTrigger = 'toggle';

        const title = document.createElement('span');
        title.className = 'apicurio-artifact-title';
        title.textContent = entry.artifactId;
        button.appendChild(title);

        const metaParts = [];
        if (entry.name) metaParts.push(entry.name);
        if (entry.version != null) metaParts.push(`v${entry.version}`);
        if (entry.type) metaParts.push(entry.type);
        if (metaParts.length) {
          const meta = document.createElement('span');
          meta.className = 'apicurio-artifact-meta';
          meta.textContent = metaParts.join(' • ');
          button.appendChild(meta);
        }

        if (entry.description) {
          const desc = document.createElement('span');
          desc.className = 'apicurio-artifact-meta';
          desc.textContent = entry.description;
          button.appendChild(desc);
        }

        li.appendChild(button);
        const versionPanel = document.createElement('div');
        versionPanel.className = 'apicurio-version-list';
        versionPanel.dataset.versionPanel = entry.artifactId;
        versionPanel.hidden = true;
        const hint = document.createElement('p');
        hint.className = 'apicurio-hint';
        hint.textContent = 'Click above to choose a version to load.';
        versionPanel.appendChild(hint);
        li.appendChild(versionPanel);
        list.appendChild(li);
      });
      apicurioArtifactsContainer.appendChild(list);
    }

    function getApicurioVersionPanel(artifactId) {
      if (!apicurioArtifactsContainer) return null;
      return apicurioArtifactsContainer.querySelector(`[data-version-panel=\"${artifactId}\"]`);
    }

    function setVersionPanelMessage(panel, message) {
      if (!panel) return;
      panel.innerHTML = '';
      if (!message) return;
      const p = document.createElement('p');
      p.className = 'apicurio-hint';
      p.textContent = message;
      panel.appendChild(p);
    }

    function renderApicurioVersionButtons(artifactId, versions) {
      const panel = getApicurioVersionPanel(artifactId);
      if (!panel) return;
      panel.innerHTML = '';
      if (!versions.length) {
        setVersionPanelMessage(panel, 'No versions found for this artifact.');
        return;
      }
      versions.forEach((ver) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'apicurio-version-button';
        btn.dataset.artifactId = artifactId;
        btn.dataset.artifactVersion = ver.version;
        const labelParts = [`Version ${ver.version}`];
        if (ver.createdOn) {
          const dt = new Date(ver.createdOn);
          if (!isNaN(dt)) {
            labelParts.push(dt.toISOString().slice(0, 10));
          }
        }
        btn.textContent = labelParts.join(' — ');
        panel.appendChild(btn);
      });
      const loadAllBtn = document.createElement('button');
      loadAllBtn.type = 'button';
      loadAllBtn.className = 'apicurio-version-button';
      loadAllBtn.dataset.artifactId = artifactId;
      loadAllBtn.dataset.artifactLoadAll = 'true';
      loadAllBtn.textContent = `Load all (${versions.length})`;
      panel.appendChild(loadAllBtn);
    }

    async function toggleArtifactVersions(artifactId) {
      const panel = getApicurioVersionPanel(artifactId);
      if (!panel) return;
      const isOpen = panel.dataset.open === 'true';
      if (isOpen) {
        panel.hidden = true;
        panel.dataset.open = 'false';
        return;
      }
      panel.hidden = false;
      panel.dataset.open = 'true';
      if (panel.dataset.loaded === 'true') return;
      if (!hasApicurioDetails()) {
        setVersionPanelMessage(panel, 'Enter registry details first.');
        return;
      }
      setVersionPanelMessage(panel, 'Loading versions…');
      try {
        const baseUrl = sanitizeApicurioBaseUrl(apicurioConfig.baseUrl);
        const groupId = apicurioConfig.groupId.trim();
        const versions = await fetchApicurioArtifactVersions(baseUrl, groupId, artifactId);
        apicurioArtifactVersions.set(artifactId, versions);
        panel.dataset.loaded = 'true';
        renderApicurioVersionButtons(artifactId, versions);
      } catch (err) {
        console.error('[Blockscape] failed to load versions', err);
        setVersionPanelMessage(panel, `Unable to fetch versions: ${err.message}`);
      }
    }

    function normalizeApicurioArtifactsPayload(payload) {
      if (Array.isArray(payload)) return payload;
      if (Array.isArray(payload?.artifacts)) return payload.artifacts;
      if (Array.isArray(payload?.items)) return payload.items;
      if (Array.isArray(payload?.results)) return payload.results;
      return [];
    }

    async function fetchApicurioArtifactMetadata(baseUrl, groupId, artifactId) {
      const encodedGroup = encodeURIComponent(groupId);
      const encodedId = encodeURIComponent(artifactId);
      const target = `${baseUrl}/groups/${encodedGroup}/artifacts/${encodedId}`;
      const headers = buildApicurioHeaders();
      headers['Accept'] = 'application/json';
      const resp = await fetch(target, { method: 'GET', headers });
      if (!resp.ok) {
        let detail = resp.statusText || 'Unknown error';
        try {
          const text = await resp.text();
          if (text) detail = text.slice(0, 400);
        } catch {
          // ignore
        }
        throw new Error(`Failed to fetch artifact metadata (${resp.status}): ${detail}`);
      }
      return resp.json();
    }

    async function fetchApicurioArtifactVersions(baseUrl, groupId, artifactId) {
      const encodedGroup = encodeURIComponent(groupId);
      const encodedId = encodeURIComponent(artifactId);
      const target = `${baseUrl}/groups/${encodedGroup}/artifacts/${encodedId}/versions?limit=50&order=desc`;
      const headers = buildApicurioHeaders();
      headers['Accept'] = 'application/json';
      const resp = await fetch(target, { method: 'GET', headers });
      if (!resp.ok) {
        let detail = resp.statusText || 'Unknown error';
        try {
          const text = await resp.text();
          if (text) detail = text.slice(0, 400);
        } catch {
          // ignore
        }
        throw new Error(`Failed to fetch artifact versions (${resp.status}): ${detail}`);
      }
      const payload = await resp.json();
      return normalizeApicurioVersionsPayload(payload).filter((v) => v && v.version != null);
    }

    function normalizeApicurioVersionsPayload(payload) {
      if (Array.isArray(payload)) return payload;
      if (Array.isArray(payload?.versions)) return payload.versions;
      if (Array.isArray(payload?.items)) return payload.items;
      return [];
    }

    function pickLatestVersionEntry(versions = []) {
      if (!Array.isArray(versions) || !versions.length) return null;
      const copy = [...versions].filter(Boolean);
      copy.sort((a, b) => {
        const aDate = a?.createdOn ? new Date(a.createdOn).getTime() : 0;
        const bDate = b?.createdOn ? new Date(b.createdOn).getTime() : 0;
        if (aDate !== bDate) return bDate - aDate;
        const aVersionNum = Number(a?.version);
        const bVersionNum = Number(b?.version);
        const aNumValid = Number.isFinite(aVersionNum);
        const bNumValid = Number.isFinite(bVersionNum);
        if (aNumValid && bNumValid && aVersionNum !== bVersionNum) {
          return bVersionNum - aVersionNum;
        }
        const aVer = String(a?.version ?? '');
        const bVer = String(b?.version ?? '');
        return bVer.localeCompare(aVer, undefined, { numeric: true });
      });
      return copy[0] || null;
    }

    function normalizeArtifactContentPayload(payload) {
      if (!payload) return payload;
      let data = payload;
      const topHasCategories = Array.isArray(payload?.categories);
      if (!topHasCategories) {
        const embedded = payload?.content;
        if (typeof embedded === 'string') {
          try {
            data = JSON.parse(embedded);
          } catch (err) {
            console.warn('[Blockscape] artifact payload contained string content that could not be parsed', err);
          }
        } else if (embedded && typeof embedded === 'object') {
          data = embedded;
        }
      }
      return data;
    }

    async function fetchApicurioArtifactContent(baseUrl, groupId, artifactId, versionSegment = 'latest') {
      const encodedGroup = encodeURIComponent(groupId);
      const encodedId = encodeURIComponent(artifactId);
      const encodedVersion = encodeURIComponent(versionSegment || 'latest');
      const contentEndpoint = `${baseUrl}/groups/${encodedGroup}/artifacts/${encodedId}/versions/${encodedVersion}/content`;
      const headers = buildApicurioHeaders();
      headers['Accept'] = 'application/json, application/*+json, */*;q=0.8';
      const resp = await fetch(contentEndpoint, { method: 'GET', headers });
      if (!resp.ok) {
        let detail = resp.statusText || 'Unknown error';
        try {
          const text = await resp.text();
          if (text) detail = text.slice(0, 400);
        } catch {
          // ignore
        }
        throw new Error(`Failed to load artifact content (${resp.status}): ${detail}`);
      }
      const text = await resp.text();
      let data = null;
      try {
        data = JSON.parse(text);
      } catch {
        throw new Error('Artifact content is not valid JSON.');
      }
      return normalizeArtifactContentPayload(data);
    }

    async function fetchApicurioArtifactFingerprint(baseUrl, groupId, artifactId, versionSegment = 'latest') {
      const data = await fetchApicurioArtifactContent(baseUrl, groupId, artifactId, versionSegment);
      return {
        data,
        fingerprint: computeJsonFingerprint(data)
      };
    }

    async function resolveApicurioCompareVersion(baseUrl, groupId, artifactId) {
      // Always fetch the current versions list for each push so we compare against the latest.
      try {
        const versions = await fetchApicurioArtifactVersions(baseUrl, groupId, artifactId);
        if (versions?.length) {
          apicurioArtifactVersions.set(artifactId, versions);
          const newestEntry = pickLatestVersionEntry(versions);
          if (newestEntry?.version != null) return newestEntry.version;
        }
      } catch (err) {
        console.warn('[Blockscape] compare-version: unable to fetch versions list', err);
      }
      // Fall back to artifact metadata if it contains a version.
      try {
        const meta = await fetchApicurioArtifactMetadata(baseUrl, groupId, artifactId);
        if (meta?.version != null) return meta.version;
      } catch (err) {
        console.warn('[Blockscape] compare-version: unable to fetch metadata', err);
      }
      // Fall back to cached versions if we have them.
      const cached = apicurioArtifactVersions.get(artifactId);
      if (cached && cached.length) {
        const newestCached = pickLatestVersionEntry(cached);
        if (newestCached?.version != null) return newestCached.version;
      }
      // Final fallback
      return 'latest';
    }

    function bindApicurioElements(scope = document) {
      pushApicurioButton = scope.querySelector('#pushApicurio') || document.getElementById('pushApicurio');
      apicurioListButton = scope.querySelector('#listApicurioArtifacts') || document.getElementById('listApicurioArtifacts');
      apicurioUrlInput = scope.querySelector('#apicurioUrl') || document.getElementById('apicurioUrl');
      apicurioGroupInput = scope.querySelector('#apicurioGroup') || document.getElementById('apicurioGroup');
      apicurioTokenInput = scope.querySelector('#apicurioToken') || document.getElementById('apicurioToken');
      apicurioToggleInput = scope.querySelector('#apicurioToggle') || document.getElementById('apicurioToggle');
      apicurioSemverInput = scope.querySelector('#apicurioSemver') || document.getElementById('apicurioSemver');
      apicurioStatusNode = scope.querySelector('#apicurioStatus') || document.getElementById('apicurioStatus');
      apicurioArtifactsContainer = scope.querySelector('#apicurioArtifacts') || document.getElementById('apicurioArtifacts');
    }

    function attachApicurioEventHandlers() {
      [apicurioUrlInput, apicurioGroupInput, apicurioTokenInput].forEach((input) => {
        if (!input) return;
        input.addEventListener('input', handleApicurioInputChange);
      });
      if (pushApicurioButton) {
        pushApicurioButton.addEventListener('click', () => {
          pushActiveModelToApicurio();
        });
      }
      if (apicurioToggleInput) {
        apicurioToggleInput.addEventListener('change', handleApicurioToggleChange);
      }
      if (apicurioSemverInput) {
        apicurioSemverInput.addEventListener('change', handleApicurioSemverToggleChange);
      }
      if (apicurioListButton) {
        apicurioListButton.addEventListener('click', listApicurioArtifacts);
      }
      if (apicurioArtifactsContainer) {
        apicurioArtifactsContainer.addEventListener('click', (event) => {
          const versionButton = event.target.closest('[data-artifact-version]');
          if (versionButton) {
            event.stopPropagation();
            const artifactId = versionButton.dataset.artifactId;
            const version = versionButton.dataset.artifactVersion;
            if (artifactId && version) {
              loadApicurioArtifact(artifactId, version);
            }
            return;
          }
          const loadAllButton = event.target.closest('[data-artifact-load-all]');
          if (loadAllButton) {
            event.stopPropagation();
            const artifactId = loadAllButton.dataset.artifactId;
            if (artifactId) {
              loadAllApicurioArtifactVersions(artifactId);
            }
            return;
          }
          const artifactTrigger = event.target.closest('[data-artifact-trigger]');
          if (artifactTrigger) {
            const artifactId = artifactTrigger.dataset.artifactId;
            if (!artifactId) return;
            toggleArtifactVersions(artifactId);
          }
        });
      }
    }

    function createApicurioPanelContent() {
      const wrapper = document.createElement('div');
      wrapper.className = 'blockscape-registry-panel';
      wrapper.innerHTML = `
        <div class="blockscape-registry-header">
          <h2>Apicurio registry</h2>
          <p>Configure the registry connection and push the active model.</p>
        </div>
        <div class="apicurio-controls">
          <label class="apicurio-toggle">
            <input id="apicurioToggle" type="checkbox" />
            <span>Enable Apicurio push</span>
          </label>
          <label class="apicurio-toggle">
            <input id="apicurioSemver" type="checkbox" />
            <span>Use semantic versioning</span>
          </label>
          <p class="apicurio-hint">When disabled, Blockscape never contacts your registry.</p>
          <p class="apicurio-hint apicurio-subnote">When on, Blockscape reads the latest version and auto-bumps the next semver on each push.</p>
          <button id="pushApicurio" class="pf-v5-c-button pf-m-secondary" type="button" disabled
            title="Enter Apicurio connection details to enable pushes">Push to Apicurio</button>
          <button id="listApicurioArtifacts" class="pf-v5-c-button pf-m-secondary" type="button" disabled
            title="List artifacts in the configured group">List artifacts</button>
          <details id="apicurioSettings" class="apicurio-settings">
            <summary>Connection settings (optional)</summary>
            <div class="apicurio-fields">
              <label>
                Registry base URL
                <input id="apicurioUrl" type="url" placeholder="https://registry.example/apis/registry/v3" autocomplete="url" />
              </label>
              <label>
                Group ID
                <input id="apicurioGroup" type="text" placeholder="default" autocomplete="organization" />
              </label>
              <label>
                Auth token (optional)
                <input id="apicurioToken" type="password" placeholder="Bearer token" autocomplete="off" />
              </label>
            </div>
            <p class="apicurio-hint">Details stay in this browser only.</p>
          </details>
          <div id="apicurioStatus" class="apicurio-status" role="status" aria-live="polite"></div>
          <div id="apicurioArtifacts" class="apicurio-artifacts" aria-live="polite"></div>
        </div>
      `;
      return wrapper;
    }

    function mountApicurioTab(panelNode) {
      if (!panelNode) return;
      panelNode.innerHTML = '';
      const content = createApicurioPanelContent();
      panelNode.appendChild(content);
      bindApicurioElements(panelNode);
      attachApicurioEventHandlers();
      refreshApicurioUiState();
    }

    function persistApicurioConfig() {
      if (!window?.localStorage) return;
      try {
        localStorage.setItem(APICURIO_STORAGE_KEY, JSON.stringify(apicurioConfig));
      } catch (err) {
        console.warn('[Blockscape] unable to persist Apicurio settings', err);
      }
    }

    function hasApicurioDetails() {
      return Boolean(apicurioConfig.baseUrl && apicurioConfig.groupId);
    }

    function isApicurioEnabled() {
      return apicurioConfig.enabled !== false;
    }

    function setApicurioStatus(message = '', tone = 'muted') {
      if (!apicurioStatusNode) return;
      apicurioStatusNode.textContent = message || '';
      apicurioStatusNode.classList.remove('is-error', 'is-success');
      if (tone === 'error') {
        apicurioStatusNode.classList.add('is-error');
      } else if (tone === 'success') {
        apicurioStatusNode.classList.add('is-success');
      }
    }

    function updateApicurioAvailability() {
      const enabled = isApicurioEnabled();
      const haveDetails = hasApicurioDetails();
      if (pushApicurioButton) {
        const isBusy = pushApicurioButton.dataset.loading === 'true';
        const ready = enabled && haveDetails && activeIndex >= 0 && !!getModelId(models[activeIndex]);
        pushApicurioButton.disabled = !enabled || isBusy || !ready;
        if (!enabled) {
          pushApicurioButton.textContent = 'Enable Apicurio to push';
        } else if (!isBusy) {
          pushApicurioButton.textContent = 'Push to Apicurio';
        }
      }
      if (apicurioListButton) {
        const listBusy = apicurioListButton.dataset.loading === 'true';
        const listReady = enabled && haveDetails;
        apicurioListButton.disabled = !listReady || listBusy;
        if (!listBusy) {
          if (!enabled) {
            apicurioListButton.textContent = 'Enable Apicurio to list';
          } else if (!haveDetails) {
            apicurioListButton.textContent = 'Enter details to list';
          } else {
            apicurioListButton.textContent = 'List artifacts';
          }
        }
      }
    }

    function buildApicurioHeaders() {
      const headers = { Accept: 'application/json' };
      const token = (apicurioConfig.authToken || '').trim();
      if (token) {
        headers['Authorization'] = /\s/.test(token) ? token : `Bearer ${token}`;
      }
      return headers;
    }

    function buildApicurioCreateBody(artifactId, contentText, { title, description, version } = {}) {
      const payload = {
        artifactId,
        artifactType: 'JSON',
        firstVersion: {
          content: {
            contentType: 'application/json',
            content: contentText
          }
        }
      };
      if (version) payload.firstVersion.version = version;
      if (title) payload.name = title;
      if (description) payload.description = description;
      return payload;
    }

    function buildApicurioUpdateBody(contentText, { version } = {}) {
      const body = {
        content: {
          contentType: 'application/json',
          content: contentText
        }
      };
      if (version) body.version = version;
      return body;
    }

    function parseApicurioSemver(value) {
      if (value == null) return null;
      const text = String(value).trim();
      if (!text) return null;
      const fullMatch = /^v?(\d+)\.(\d+)\.(\d+)(?:-.+)?$/.exec(text);
      if (fullMatch) {
        return {
          major: Number(fullMatch[1]),
          minor: Number(fullMatch[2]),
          patch: Number(fullMatch[3])
        };
      }
      const majorOnly = /^v?(\d+)$/.exec(text);
      if (majorOnly) {
        return {
          major: Number(majorOnly[1]),
          minor: 0,
          patch: 0
        };
      }
      return null;
    }

    function formatSemverParts(parts) {
      return `${parts.major}.${parts.minor}.${parts.patch}`;
    }

    function compareSemverParts(a, b) {
      if (!a && !b) return 0;
      if (!a) return -1;
      if (!b) return 1;
      if (a.major !== b.major) return a.major - b.major;
      if (a.minor !== b.minor) return a.minor - b.minor;
      return a.patch - b.patch;
    }

    function computeNextSemverVersion(versions = []) {
      let latest = null;
      versions.forEach((entry) => {
        const parsed = parseApicurioSemver(entry?.version ?? entry);
        if (!parsed) return;
        if (!latest || compareSemverParts(parsed, latest) > 0) {
          latest = parsed;
        }
      });
      if (!latest) return '1.0.0';
      const bumped = { ...latest, patch: latest.patch + 1 };
      return formatSemverParts(bumped);
    }

    async function resolveApicurioSemverTarget(baseUrl, groupId, artifactId, exists) {
      if (!apicurioConfig.useSemver) return null;
      if (!exists) return '1.0.0';
      try {
        const versions = await fetchApicurioArtifactVersions(baseUrl, groupId, artifactId);
        return computeNextSemverVersion(versions);
      } catch (err) {
        throw new Error(`Unable to compute next semantic version: ${err.message}`);
      }
    }

    function handleApicurioInputChange() {
      apicurioConfig.baseUrl = sanitizeApicurioBaseUrl(apicurioUrlInput?.value ?? apicurioConfig.baseUrl);
      apicurioConfig.groupId = (apicurioGroupInput?.value ?? '').trim();
      apicurioConfig.authToken = (apicurioTokenInput?.value ?? '').trim();
      persistApicurioConfig();
      refreshApicurioUiState();
    }

    function handleApicurioToggleChange() {
      apicurioConfig.enabled = apicurioToggleInput ? apicurioToggleInput.checked : DEFAULT_APICURIO_ENABLED;
      persistApicurioConfig();
      refreshApicurioUiState();
    }

    function handleApicurioSemverToggleChange() {
      apicurioConfig.useSemver = apicurioSemverInput ? apicurioSemverInput.checked : DEFAULT_APICURIO_SEMVER_ENABLED;
      persistApicurioConfig();
      refreshApicurioUiState();
    }

    async function apicurioArtifactExists(baseUrl, groupId, artifactId, headers) {
      const encodedGroup = encodeURIComponent(groupId);
      const encodedId = encodeURIComponent(artifactId);
      const target = `${baseUrl}/groups/${encodedGroup}/artifacts/${encodedId}`;
      try {
        const resp = await fetch(target, { method: 'GET', headers });
        if (resp.status === 404) return false;
        if (resp.ok) return true;
        if (resp.status === 401 || resp.status === 403) {
          throw new Error('Authentication failed while checking the registry.');
        }
        throw new Error(`Registry responded with status ${resp.status} while checking the artifact.`);
      } catch (err) {
        if (err instanceof TypeError) {
        throw new Error('Network error while contacting Apicurio registry.');
        }
        throw err;
      }
    }

    function upsertModelEntryForArtifact(artifactId, entry) {
      const existingIndex = models.findIndex(m => m.apicurioArtifactId === artifactId);
      if (existingIndex !== -1) {
        const preservedId = models[existingIndex].id;
        models[existingIndex] = { ...entry, id: preservedId || entry.id };
        setActive(existingIndex);
      } else {
        models.push(entry);
        setActive(models.length - 1);
      }
    }

    async function pushActiveModelToApicurio() {
      if (!pushApicurioButton || pushApicurioButton.dataset.loading === 'true') return;
      if (!isApicurioEnabled()) {
        setApicurioStatus('Apicurio integration is off. Enable it first.', 'error');
        return;
      }
      if (!hasApicurioDetails()) {
        setApicurioStatus('Enter the registry base URL and group ID before pushing.', 'error');
        return;
      }
      if (activeIndex < 0 || !models[activeIndex]) {
        setApicurioStatus('No active model to push.', 'error');
        return;
      }
      const artifactId = getModelId(models[activeIndex]);
      if (!artifactId) {
        setApicurioStatus('Active model needs an id before pushing.', 'error');
        return;
      }

      const baseUrl = sanitizeApicurioBaseUrl(apicurioConfig.baseUrl);
      const groupId = apicurioConfig.groupId.trim();
      const payload = JSON.stringify(models[activeIndex].data, null, 2);
      const headers = buildApicurioHeaders();

      pushApicurioButton.dataset.loading = 'true';
      pushApicurioButton.textContent = 'Pushing…';
      pushApicurioButton.disabled = true;
      setApicurioStatus('Pushing to Apicurio…', 'muted');

      try {
        const exists = await apicurioArtifactExists(baseUrl, groupId, artifactId, headers);
        const localFingerprint = computeJsonFingerprint(models[activeIndex].data);
        if (exists) {
          try {
            const compareVersion = await resolveApicurioCompareVersion(baseUrl, groupId, artifactId);
            const { data: registryData, fingerprint: registryFingerprint } = await fetchApicurioArtifactFingerprint(baseUrl, groupId, artifactId, compareVersion);
            console.group('[Blockscape] Apicurio push compare');
            console.log('compare version', compareVersion);
            console.log('local fingerprint', localFingerprint);
            console.log('registry fingerprint', registryFingerprint);
            console.log('local payload', models[activeIndex].data);
            console.log('registry payload', registryData);
            console.groupEnd();
            if (localFingerprint && registryFingerprint && localFingerprint === registryFingerprint) {
              const proceed = window.confirm('The current registry version is identical to this model. Push anyway?');
              if (!proceed) {
                setApicurioStatus('Push cancelled (content matches the latest registry version).', 'muted');
                return;
              }
              setApicurioStatus('Pushing identical content by user choice.', 'muted');
            } else if (!registryFingerprint) {
              setApicurioStatus('Unable to compare with registry content (skipping confirmation).', 'muted');
            } else {
              console.log('[Blockscape] Apicurio compare mismatch (proceeding with push)');
            }
          } catch (compareError) {
            console.warn('[Blockscape] unable to compare registry content before push', compareError);
            setApicurioStatus('Skipped comparison with registry (content fetch failed). Proceeding with push.', 'muted');
          }
        }
        const targetVersion = apicurioConfig.useSemver
          ? await resolveApicurioSemverTarget(baseUrl, groupId, artifactId, exists)
          : null;
        if (apicurioConfig.useSemver && !targetVersion) {
          throw new Error('Semantic versioning is enabled but no version could be computed.');
        }
        const encodedGroup = encodeURIComponent(groupId);
        const encodedId = encodeURIComponent(artifactId);
        const endpoint = exists
          ? `${baseUrl}/groups/${encodedGroup}/artifacts/${encodedId}/versions`
          : `${baseUrl}/groups/${encodedGroup}/artifacts`;

        const requestHeaders = {
          ...headers,
          'Content-Type': 'application/json'
        };
        if (targetVersion) {
          requestHeaders['X-Registry-Version'] = targetVersion;
          setApicurioStatus(`Pushing to Apicurio as version ${targetVersion}…`, 'muted');
        }

        const bodyObject = exists
          ? buildApicurioUpdateBody(payload, { version: targetVersion })
          : buildApicurioCreateBody(artifactId, payload, {
            title: getModelTitle(models[activeIndex]),
            description: models[activeIndex].data?.abstract,
            version: targetVersion
          });

        const response = await fetch(endpoint, {
          method: 'POST',
          headers: requestHeaders,
          body: JSON.stringify(bodyObject)
        });

        if (!response.ok) {
          let detail = response.statusText || 'Unknown error';
          try {
            const text = await response.text();
            if (text) detail = text.slice(0, 400);
          } catch {
            // ignore
          }
          throw new Error(`Registry rejected the push (${response.status}): ${detail}`);
        }

        let info = null;
        try {
          info = await response.json();
        } catch {
          info = null;
        }
        const label = info?.version || info?.globalId || '';
        const prefix = exists ? 'Updated' : 'Created';
        const suffix = label ? ` (version ${label})` : '';
        setApicurioStatus(`${prefix} ${artifactId}${suffix}`, 'success');
      } catch (error) {
        console.error('[Blockscape] Apicurio push failed', error);
        setApicurioStatus(`Apicurio push failed: ${error.message}`, 'error');
      } finally {
        pushApicurioButton.dataset.loading = 'false';
        updateApicurioAvailability();
      }
    }

    async function listApicurioArtifacts() {
      if (!apicurioListButton || apicurioListButton.dataset.loading === 'true') return;
      if (!isApicurioEnabled()) {
        setApicurioStatus('Enable Apicurio integration to list artifacts.', 'error');
        return;
      }
      if (!hasApicurioDetails()) {
        setApicurioStatus('Enter registry base URL and group ID before listing.', 'error');
        return;
      }
      const baseUrl = sanitizeApicurioBaseUrl(apicurioConfig.baseUrl);
      const groupId = apicurioConfig.groupId.trim();
      const encodedGroup = encodeURIComponent(groupId);
      const endpoint = `${baseUrl}/groups/${encodedGroup}/artifacts?limit=50&offset=0`;
      apicurioListButton.dataset.loading = 'true';
      apicurioListButton.textContent = 'Listing…';
      apicurioListButton.disabled = true;
      setApicurioStatus('Listing artifacts…', 'muted');
      setApicurioArtifactsMessage('Contacting registry…');
      try {
        const headers = buildApicurioHeaders();
        headers['Accept'] = 'application/json';
        const resp = await fetch(endpoint, { method: 'GET', headers });
        if (!resp.ok) {
          let detail = resp.statusText || 'Unknown error';
          try {
            const text = await resp.text();
            if (text) detail = text.slice(0, 400);
          } catch {
            // ignore
          }
          throw new Error(`Failed to list artifacts (${resp.status}): ${detail}`);
        }
        const payload = await resp.json();
        const entries = normalizeApicurioArtifactsPayload(payload).filter(item => item && item.artifactId);
        apicurioArtifactsById.clear();
        apicurioArtifactVersions.clear();
        entries.forEach(item => {
          if (item?.artifactId) {
            apicurioArtifactsById.set(item.artifactId, item);
          }
        });
        renderApicurioArtifactsList(entries);
        const count = entries.length;
        setApicurioStatus(count ? `Found ${count} artifact${count === 1 ? '' : 's'}.` : 'No artifacts found in this group.', count ? 'success' : 'muted');
      } catch (err) {
        console.error('[Blockscape] failed to list artifacts', err);
        resetApicurioArtifactsPanel('Unable to list artifacts.');
        setApicurioStatus(`Listing failed: ${err.message}`, 'error');
      } finally {
        apicurioListButton.dataset.loading = 'false';
        updateApicurioAvailability();
      }
    }

    async function loadApicurioArtifact(artifactId, explicitVersion = null) {
      if (!artifactId) return;
      if (!isApicurioEnabled()) {
        setApicurioStatus('Enable Apicurio integration to load artifacts.', 'error');
        return;
      }
      if (!hasApicurioDetails()) {
        setApicurioStatus('Enter registry connection details before loading artifacts.', 'error');
        return;
      }
      const baseUrl = sanitizeApicurioBaseUrl(apicurioConfig.baseUrl);
      const groupId = apicurioConfig.groupId.trim();
      let meta = apicurioArtifactsById.get(artifactId);
      const ensureMetadata = async () => {
        try {
          const fresh = await fetchApicurioArtifactMetadata(baseUrl, groupId, artifactId);
          if (fresh?.artifactId) {
            apicurioArtifactsById.set(artifactId, fresh);
          }
          return fresh;
        } catch (err) {
          console.error('[Blockscape] failed to fetch artifact metadata before loading', err);
          throw err;
        }
      };
      if (!meta) {
        try {
          meta = await ensureMetadata();
        } catch (err) {
          setApicurioStatus(`Failed to fetch artifact metadata: ${err.message}`, 'error');
          return;
        }
      }
      const knownVersions = apicurioArtifactVersions.get(artifactId) || [];
      let versionSegment = 'latest';
      let versionLabel = 'latest';
      if (explicitVersion) {
        versionSegment = explicitVersion;
        versionLabel = explicitVersion;
      } else {
        if (!meta || meta.version == null) {
          try {
            meta = await ensureMetadata();
          } catch (err) {
            setApicurioStatus(`Failed to fetch artifact metadata: ${err.message}`, 'error');
            return;
          }
        }
        versionSegment = meta?.version || 'latest';
        versionLabel = meta?.version || 'latest';
      }
      const matchedVersion = knownVersions.find((v) => String(v.version) === String(versionSegment));
      if (matchedVersion?.version != null) {
        versionLabel = matchedVersion.version;
      }
      setApicurioStatus(`Loading artifact ${artifactId}…`, 'muted');
      try {
        const data = await fetchApicurioArtifactContent(baseUrl, groupId, artifactId, versionSegment);
        const resolvedMeta = apicurioArtifactsById.get(artifactId) || meta || {};
        ensureModelMetadata(data, { titleHint: resolvedMeta.name || artifactId, idHint: artifactId });
        const versionEntry = {
          version: versionLabel,
          data,
          createdOn: matchedVersion?.createdOn || resolvedMeta.createdOn
        };
        const entry = {
          id: uid(),
          title: data.title || resolvedMeta.name || artifactId,
          data,
          apicurioArtifactId: artifactId,
          apicurioArtifactName: resolvedMeta.name || '',
          apicurioVersions: [versionEntry],
          apicurioActiveVersionIndex: 0
        };
        upsertModelEntryForArtifact(artifactId, entry);
        const suffix = versionLabel ? ` (version ${versionLabel})` : '';
        setApicurioStatus(`Loaded artifact ${artifactId}${suffix}.`, 'success');
      } catch (err) {
        console.error('[Blockscape] failed to load artifact', err);
        setApicurioStatus(`Failed to load artifact: ${err.message}`, 'error');
      }
    }

    async function loadAllApicurioArtifactVersions(artifactId) {
      if (!artifactId) return;
      if (!isApicurioEnabled()) {
        setApicurioStatus('Enable Apicurio integration to load artifacts.', 'error');
        return;
      }
      if (!hasApicurioDetails()) {
        setApicurioStatus('Enter registry connection details before loading artifacts.', 'error');
        return;
      }
      const baseUrl = sanitizeApicurioBaseUrl(apicurioConfig.baseUrl);
      const groupId = apicurioConfig.groupId.trim();
      let versions = apicurioArtifactVersions.get(artifactId);
      if (!versions) {
        setVersionPanelMessage(getApicurioVersionPanel(artifactId), 'Loading versions…');
        try {
          versions = await fetchApicurioArtifactVersions(baseUrl, groupId, artifactId);
          apicurioArtifactVersions.set(artifactId, versions);
        } catch (err) {
          setApicurioStatus(`Failed to fetch versions: ${err.message}`, 'error');
          return;
        }
      }
      const normalized = (versions || []).filter(v => v && v.version != null);
      if (!normalized.length) {
        setApicurioStatus('No versions found for this artifact.', 'muted');
        return;
      }
      setApicurioStatus(`Loading ${normalized.length} version(s) for ${artifactId}…`, 'muted');
      const resolvedMeta = apicurioArtifactsById.get(artifactId) || {};
      const versionEntries = [];
      try {
        for (const ver of normalized) {
          const label = ver.version ?? 'latest';
          const content = await fetchApicurioArtifactContent(baseUrl, groupId, artifactId, label);
          ensureModelMetadata(content, { titleHint: resolvedMeta.name || artifactId, idHint: artifactId });
          versionEntries.push({
            version: label,
            createdOn: ver.createdOn,
            data: content
          });
        }
      } catch (err) {
        console.error('[Blockscape] failed to load one or more versions', err);
        setApicurioStatus(`Failed to load all versions: ${err.message}`, 'error');
        return;
      }
      if (!versionEntries.length) {
        setApicurioStatus('No versions loaded from registry.', 'error');
        return;
      }
      const entry = {
        id: uid(),
        title: versionEntries[0].data.title || resolvedMeta.name || artifactId,
        data: versionEntries[0].data,
        apicurioArtifactId: artifactId,
        apicurioArtifactName: resolvedMeta.name || '',
        apicurioVersions: versionEntries,
        apicurioActiveVersionIndex: 0
      };
      upsertModelEntryForArtifact(artifactId, entry);
      setApicurioStatus(`Loaded ${versionEntries.length} version(s) for ${artifactId}.`, 'success');
    }

    function syncDocumentTitle() {
      const activeModel = (activeIndex >= 0 && models[activeIndex]) ? models[activeIndex] : null;
      const modelId = getModelId(activeModel);
      document.title = modelId ? `${modelId}-blockscape` : defaultDocumentTitle;
    }

    function downloadCurrentJson(source = 'shortcut') {
      const text = jsonBox.value || '';
      if (!text.trim()) {
        console.warn("[Blockscape] download ignored: JSON box is empty.");
        return false;
      }
      const title = getModelTitle(models[activeIndex], 'blockscape');
      const filename = `${makeDownloadName(title)}.json`;
      download(filename, text);
      console.log(`[Blockscape] saved JSON (${source}):`, filename);
      return true;
    }

    // --- NEW: letter → color mapping and helpers ---
    // Letter → color mapping (tailwind-ish palette). G => green.
    const LETTER_COLOR_MAP = {
      A: '#ef4444', B: '#3b82f6', C: '#06b6d4', D: '#a855f7',
      E: '#f59e0b', F: '#f97316', G: '#22c55e', H: '#84cc16',
      I: '#10b981', J: '#14b8a6', K: '#0ea5e9', L: '#60a5fa',
      M: '#8b5cf6', N: '#d946ef', O: '#f43f5e', P: '#e11d48',
      Q: '#dc2626', R: '#f59e0b', S: '#eab308', T: '#a3e635',
      U: '#22d3ee', V: '#38bdf8', W: '#818cf8', X: '#a78bfa',
      Y: '#f472b6', Z: '#fb7185'
    };

    // Prefer explicit item.color (if present), else map by first letter.
    function getBadgeColor(text, explicit) {
      if (explicit && /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(explicit)) return explicit;
      const ch = (text || '?').charAt(0).toUpperCase();
      return LETTER_COLOR_MAP[ch] || '#9ca3af'; // fallback gray
    }

    // Compute readable letter color (black/white) against bg
    function idealTextColor(bgHex) {
      const hex = bgHex.replace('#', '');
      const expanded = hex.length === 3 ? hex.split('').map(c=>c+c).join('') : hex;
      const bigint = parseInt(expanded, 16);
      const r = (bigint >> 16) & 255, g = (bigint >> 8) & 255, b = bigint & 255;
      // luminance (sRGB)
      const L = 0.2126*Math.pow(r/255,2.2) + 0.7152*Math.pow(g/255,2.2) + 0.0722*Math.pow(b/255,2.2);
      return L > 0.35 ? '#111111' : '#ffffff';
    }

    function scrollPageToTop() {
      if (typeof window === 'undefined' || typeof window.scrollTo !== 'function') return;
      try {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      } catch (err) {
        window.scrollTo(0, 0);
      }
    }

    let overlaySyncPending = false;
    function scheduleOverlaySync() {
      if (overlaySyncPending) return;
      overlaySyncPending = true;
      requestAnimationFrame(() => {
        overlaySyncPending = false;
        reflowRects();
        drawLinks();
      });
    }

    let globalEventsBound = false;

    function setActive(i) {
      hidePreview();
      lastDeletedItem = null;
      if (i < 0 || i >= models.length) {
        console.warn("[Blockscape] setActive called with out-of-range index:", i);
        return;
      }
      activeIndex = i;
      console.log("[Blockscape] active model:", getModelTitle(models[i]), "(index", i + " )");
      syncDocumentTitle();
      renderModelList();
      loadActiveIntoEditor();
      rebuildFromActive();
      updateApicurioAvailability();
    }

    function renderModelList() {
      modelList.innerHTML = "";
      if (!models.length) {
        const empty = document.createElement('li');
        empty.className = 'model-nav-empty';
        empty.textContent = 'No models loaded yet.';
        modelList.appendChild(empty);
        return;
      }

      models.forEach((m, i) => {
        const li = document.createElement('li');
        li.className = 'model-nav-item';

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'model-nav-button' + (i === activeIndex ? ' is-active' : '');
        btn.dataset.index = String(i);
        btn.setAttribute('aria-current', i === activeIndex ? 'true' : 'false');

        const label = document.createElement('span');
        label.className = 'model-nav-label';

        const titleSpan = document.createElement('span');
        titleSpan.className = 'model-nav-title';
        titleSpan.textContent = getModelTitle(m);
        label.appendChild(titleSpan);

        const dataId = getModelId(m);
        if (dataId) {
          const idBadge = document.createElement('span');
          idBadge.className = 'model-nav-id';
          idBadge.textContent = dataId;
          label.appendChild(idBadge);
        }

        const categories = Array.isArray(m.data?.categories) ? m.data.categories : [];
        const itemsCount = categories.reduce((sum, cat) => sum + ((cat.items || []).length), 0);

        const meta = document.createElement('span');
        meta.className = 'model-nav-meta';
        const versionsInfo = (m.apicurioVersions && m.apicurioVersions.length > 1)
          ? ` · ${m.apicurioVersions.length} versions`
          : '';
        meta.textContent = `${categories.length} cat · ${itemsCount} items${versionsInfo}`;

        btn.appendChild(label);
        btn.appendChild(meta);
        li.appendChild(btn);
        modelList.appendChild(li);
      });

      updateApicurioAvailability();
    }

    function loadActiveIntoEditor() {
      if (activeIndex < 0) { jsonBox.value = ""; return; }
      jsonBox.value = JSON.stringify(models[activeIndex].data, null, 2);
    }

    function tryParseJson(txt) { try { return JSON.parse(txt); } catch { return null; } }

    // Collapse multi-doc imports with the same model id into a single entry with version navigation.
    function collapseEntriesToVersionedModel(entries, { versionPrefix = 'v' } = {}) {
      if (!Array.isArray(entries) || entries.length < 2) return entries;
      const ids = entries.map((en) => getModelId(en)).filter(Boolean);
      if (ids.length !== entries.length) return entries;
      const uniqueIds = Array.from(new Set(ids));
      if (uniqueIds.length !== 1) return entries;

      const sharedId = uniqueIds[0];
      const versions = entries.map((entry, idx) => {
        const explicitVersion = (entry.data?.version ?? '').toString().trim();
        return {
          version: explicitVersion || `${versionPrefix}${idx + 1}`,
          data: entry.data
        };
      });
      const activeIdx = versions.length - 1;
      const activeEntry = entries[activeIdx] || entries[0];
      const activeTitle = getModelTitle(activeEntry, sharedId);

      return [{
        id: uid(),
        title: activeTitle,
        data: versions[activeIdx]?.data || activeEntry.data,
        apicurioArtifactId: sharedId,
        apicurioArtifactName: activeTitle,
        apicurioVersions: versions,
        apicurioActiveVersionIndex: activeIdx
      }];
    }

    // Accept 1) object, 2) array-of-objects, 3) '---' or '%%%' separated objects
    function normalizeToModelsFromText(txt, titleBase = "Pasted") {
      const trimmed = (txt || "").trim();
      if (!trimmed) return [];
      const parsed = tryParseJson(trimmed);
      let entries = [];
      if (parsed) {
        const arr = Array.isArray(parsed) ? parsed : [parsed];
        entries = arr.map((o, idx) => {
          ensureModelMetadata(o, { titleHint: `${titleBase} #${idx + 1}` });
          return {
            id: uid(),
            title: o.title || `${titleBase} #${idx + 1}`,
            data: o
          };
        });
      } else {
        const parts = trimmed.split(/^\s*(?:---|%%%)\s*$/m).map(s => s.trim()).filter(Boolean);
        entries = parts.map((p, i) => {
          const obj = JSON.parse(p);
          ensureModelMetadata(obj, { titleHint: `${titleBase} #${i + 1}` });
          return {
            id: uid(),
            title: obj.title || `${titleBase} #${i + 1}`,
            data: obj
          };
        });
      }
      return collapseEntriesToVersionedModel(entries);
    }

    function isEditableElement(el) {
      if (!el) return false;
      if (el.isContentEditable) return true;
      const tag = (el.tagName || '').toLowerCase();
      return tag === 'input' || tag === 'textarea' || tag === 'select';
    }

    function shouldHandleGlobalPaste() {
      const active = document.activeElement;
      if (!active || active === document.body || active === document.documentElement) return true;
      return !isEditableElement(active);
    }

    function looksLikeModelJson(text) {
      if (!text) return false;
      const start = text.trimStart();
      return /^\s*(\{|\[|---|%%%)/.test(start);
    }

    function consumeEditorPayload() {
      if (typeof window === 'undefined' || !window.localStorage) return null;
      let raw;
      try {
        raw = localStorage.getItem(EDITOR_TRANSFER_KEY);
      } catch (err) {
        console.warn('[Blockscape] failed to access editor payload', err);
        return null;
      }
      if (!raw) return null;
      let payload;
      try {
        payload = JSON.parse(raw);
      } catch (err) {
        console.warn('[Blockscape] invalid payload JSON', err);
        try { localStorage.removeItem(EDITOR_TRANSFER_KEY); } catch (_) {}
        return null;
      }
      if (payload?.source !== 'editor') return null;
      try {
        localStorage.removeItem(EDITOR_TRANSFER_KEY);
      } catch (err) {
        console.warn('[Blockscape] failed to clear editor payload', err);
      }
      if (!payload.text || typeof payload.text !== 'string') {
        console.warn('[Blockscape] payload missing text');
        return null;
      }
      let entries = [];
      try {
        entries = normalizeToModelsFromText(payload.text, payload.title || 'Editor Export');
      } catch (err) {
        console.warn('[Blockscape] could not parse payload text', err);
        return null;
      }
      if (!entries.length) return null;
      const startIndex = models.length;
      entries.forEach(entry => models.push(entry));
      console.log(`[Blockscape] imported ${entries.length} model(s) from editor`);
      return startIndex;
    }

    function importEditorPayload(trigger = 'storage') {
      const startIndex = consumeEditorPayload();
      if (typeof startIndex !== 'number') return false;
      const importedCount = models.length - startIndex;
      setActive(startIndex);
      console.log(`[Blockscape] imported ${importedCount} model(s) from editor via ${trigger}.`);
      return true;
    }

    function updateShareHashForModel(model, fallbackTitle = 'Shared Model') {
      if (!model || !model.data) {
        throw new Error('Select or load a model before sharing.');
      }
      let encoded;
      const payload = {
        title: getModelTitle(model, fallbackTitle),
        data: model.data
      };
      try {
        encoded = base64UrlEncode(JSON.stringify(payload));
      } catch (err) {
        console.error('[Blockscape] share encode failed', err);
        throw new Error('Unable to encode this model for sharing.');
      }

      const shareUrl = new URL(window.location.href);
      shareUrl.searchParams.delete('share');
      shareUrl.hash = `share=${encoded}`;

      try {
        window.history.replaceState({}, document.title, shareUrl.toString());
      } catch (err) {
        console.warn('[Blockscape] failed to update URL for share', err);
        window.location.hash = shareUrl.hash;
      }
      return shareUrl;
    }

    function consumeShareLink() {
      const hash = window.location.hash || '';
      let token = null;
      let source = null;

      const hashMatch = hash.match(/share=([^&]+)/);
      if (hashMatch) {
        token = hashMatch[1];
        source = 'hash';
      }

      if (!token) {
        const params = new URLSearchParams(window.location.search);
        if (params.has('share')) {
          token = params.get('share');
          source = 'search';
        }
      }

      if (!token) return null;

      let payload;
      try {
        const text = base64UrlDecode(token);
        payload = JSON.parse(text);
      } catch (err) {
        console.warn('[Blockscape] failed to decode share token', err);
        return null;
      }

      if (!payload || typeof payload !== 'object' || typeof payload.data !== 'object') {
        console.warn('[Blockscape] share payload missing data');
        return null;
      }

      ensureModelMetadata(payload.data, { titleHint: payload.title || 'Shared Model' });

      models.push({
        id: uid(),
        title: payload.data.title || payload.title || 'Shared Model',
        data: payload.data
      });

      return models.length - 1;
    }

    async function consumeLoadParam() {
      const hash = window.location.hash || '';
      let target = null;

      const hashMatch = hash.match(/load=([^&]+)/);
      if (hashMatch) {
        try {
          target = decodeURIComponent(hashMatch[1]);
        } catch {
          target = hashMatch[1];
        }
      }

      if (!target) {
        const params = new URLSearchParams(window.location.search);
        if (params.has('load')) {
          target = params.get('load');
        }
      }

      if (!target) return null;

      try {
        const startIndex = models.length;
        const ok = await loadFromUrl(target);
        if (!ok) return null;
        const added = models.length - startIndex;
        return added > 0 ? startIndex : null;
      } catch (err) {
        console.warn('[Blockscape] load param failed', err);
        return null;
      }
    }

    function parse(mObj) {
      console.log("[Blockscape] parsing model; categories=", (mObj?.categories || []).length);
      const fwd = new Map();
      const rev = new Map();
      const seen = new Set();

      (mObj.categories || []).forEach(c => (c.items || []).forEach(it => {
        seen.add(it.id);
        const deps = new Set(it.deps || []);
        (mObj.links || []).forEach(l => { if (l.from === it.id) deps.add(l.to); });
        fwd.set(it.id, deps);
        deps.forEach(d => {
          if (!rev.has(d)) rev.set(d, new Set());
          rev.get(d).add(it.id);
        });
      }));

      const reusedLocal = new Set();
      rev.forEach((dependents, node) => { if ((dependents?.size || 0) >= 2) reusedLocal.add(node); });
      return { m: mObj, fwd, rev, reusedLocal, seen };
    }

    // --- MODIFIED: color-aware letter image ---
    function generateLetterImage(text, explicitColor) {
      console.log("[Blockscape] generateLetterImage for:", text);
      const canvas = document.createElement('canvas');
      const size = 44;
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext('2d');

      const letter = (text || '?').charAt(0).toUpperCase();
      const bg = getBadgeColor(text, explicitColor);
      const fg = idealTextColor(bg);

      // Circle
      ctx.fillStyle = bg;
      ctx.beginPath();
      ctx.arc(size/2, size/2, size/2 - 2, 0, 2*Math.PI);
      ctx.fill();

      // Subtle ring
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Letter
      ctx.fillStyle = fg;
      ctx.font = `bold ${size * 0.5}px system-ui, -apple-system, sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(letter, size/2, size/2);

      return canvas.toDataURL('image/png');
    }

    function getActiveApicurioVersionIndex(entry) {
      if (!entry?.apicurioVersions?.length) return -1;
      const idx = Number.isInteger(entry.apicurioActiveVersionIndex) ? entry.apicurioActiveVersionIndex : 0;
      return Math.min(Math.max(idx, 0), entry.apicurioVersions.length - 1);
    }

    function getActiveApicurioVersionLabel(entry) {
      const idx = getActiveApicurioVersionIndex(entry);
      if (idx === -1) return null;
      const versionEntry = entry.apicurioVersions[idx];
      return versionEntry?.version ?? null;
    }

    function getModelVersionLabel(entry) {
      const apicurioVersion = getActiveApicurioVersionLabel(entry);
      if (apicurioVersion) return apicurioVersion;
      const rawVersion = entry?.data?.version;
      if (rawVersion == null) return null;
      const trimmed = rawVersion.toString().trim();
      return trimmed || null;
    }

    function setActiveApicurioVersion(entryIndex, versionIndex) {
      if (entryIndex < 0 || entryIndex >= models.length) return false;
      const entry = models[entryIndex];
      if (!entry?.apicurioVersions?.length) return false;
      const count = entry.apicurioVersions.length;
      const normalized = ((versionIndex % count) + count) % count;
      const target = entry.apicurioVersions[normalized];
      if (!target?.data) return false;
      entry.apicurioActiveVersionIndex = normalized;
      entry.data = target.data;
      selection = null;
      loadActiveIntoEditor();
      rebuildFromActive();
      return true;
    }

    function stepApicurioVersion(step) {
      if (!step || activeIndex < 0) return;
      const entry = models[activeIndex];
      if (!entry?.apicurioVersions?.length) return;
      const current = getActiveApicurioVersionIndex(entry);
      if (current === -1) return;
      setActiveApicurioVersion(activeIndex, current + step);
    }

    function renderVersionNavigator(entry) {
      if (!entry?.apicurioVersions || entry.apicurioVersions.length <= 1) return null;
      const nav = document.createElement('div');
      nav.className = 'version-nav';

      const title = document.createElement('div');
      title.className = 'version-nav__title';
      title.textContent = entry.apicurioArtifactName || entry.apicurioArtifactId || getModelId(entry) || 'Artifact';
      nav.appendChild(title);

      const status = document.createElement('div');
      status.className = 'version-nav__status';
      const activeIdx = getActiveApicurioVersionIndex(entry);
      const activeVersionLabel = getActiveApicurioVersionLabel(entry) || 'latest';
      status.textContent = `Version ${activeVersionLabel} (${activeIdx + 1} of ${entry.apicurioVersions.length})`;
      nav.appendChild(status);

      const controls = document.createElement('div');
      controls.className = 'version-nav__controls';
      const prevBtn = document.createElement('button');
      prevBtn.type = 'button';
      prevBtn.className = 'version-nav__button';
      prevBtn.textContent = 'Previous';
      prevBtn.addEventListener('click', () => stepApicurioVersion(-1));

      const nextBtn = document.createElement('button');
      nextBtn.type = 'button';
      nextBtn.className = 'version-nav__button';
      nextBtn.textContent = 'Next';
      nextBtn.addEventListener('click', () => stepApicurioVersion(1));

      controls.appendChild(prevBtn);
      controls.appendChild(nextBtn);
      nav.appendChild(controls);

      return nav;
    }

    // ===== Render =====
    function render() {
      if (!model) return;
      hideTabTooltip();
      if (!Array.isArray(model.m.categories)) {
        model.m.categories = [];
      }
      console.log("[Blockscape] rendering categories=", model.m.categories.length);
      console.log("[Blockscape] model.m has abstract?", !!model.m.abstract, "- value:", model.m.abstract ? model.m.abstract.substring(0, 50) + "..." : "none");
      app.innerHTML = "";
      index.clear();

      const versionNav = renderVersionNavigator(models[activeIndex]);
      if (versionNav) {
        app.appendChild(versionNav);
      }

      overlay.setAttribute("width", window.innerWidth);
      overlay.setAttribute("height", window.innerHeight);

      const meta = document.createElement('div');
      meta.className = 'blockscape-model-meta';

      const titleEl = document.createElement('div');
      titleEl.className = 'blockscape-model-title';
      titleEl.textContent = (model.m.title && model.m.title.trim()) || getModelTitle(models[activeIndex]);
      meta.appendChild(titleEl);

      const activeVersionLabel = getModelVersionLabel(models[activeIndex]);
      const normalizedId = (model.m.id ?? '').toString().trim();
      if (normalizedId) {
        const idEl = document.createElement('div');
        idEl.className = 'blockscape-model-id';
        idEl.textContent = `ID: ${normalizedId}`;
        meta.appendChild(idEl);
      }
      if (activeVersionLabel) {
        const versionEl = document.createElement('div');
        versionEl.className = 'blockscape-model-id';
        versionEl.textContent = `Version: ${activeVersionLabel}`;
        meta.appendChild(versionEl);
      }

      app.appendChild(meta);
      const tabsWrapper = document.createElement('div');
      tabsWrapper.className = 'blockscape-tabs';

      const tabList = document.createElement('div');
      tabList.className = 'blockscape-tablist';
      tabList.setAttribute('role', 'tablist');
      tabsWrapper.appendChild(tabList);

      const panelsWrapper = document.createElement('div');
      panelsWrapper.className = 'blockscape-tabpanels';
      tabsWrapper.appendChild(panelsWrapper);

      const mapPanel = document.createElement('div');
      const abstractPanel = document.createElement('div');
      const sourcePanel = document.createElement('div');
      const apicurioPanel = document.createElement('div');
      let infoTooltipHtml = '';

      const tabDefs = [
        { id: 'map', label: 'Map', panel: mapPanel },
        { id: 'abstract', label: 'Info', panel: abstractPanel },
        { id: 'source', label: 'Source', panel: sourcePanel },
        { id: 'apicurio', label: 'Apicurio', panel: apicurioPanel }
      ];

      const handleTabVisibility = (tabId) => {
        if (!overlay) return;
        const showOverlay = tabId === 'map';
        overlay.hidden = !showOverlay;
        if (showOverlay) {
          reflowRects();
          drawLinks();
        } else {
          overlay.innerHTML = '';
        }
      };

      tabDefs.forEach((tab, idx) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.id = `tab-${tab.id}`;
        button.className = 'blockscape-tab' + (idx === 0 ? ' is-active' : '');
        button.setAttribute('role', 'tab');
        button.setAttribute('aria-controls', `panel-${tab.id}`);
        button.setAttribute('aria-selected', idx === 0 ? 'true' : 'false');
        button.textContent = tab.label;
        tab.button = button;
        tabList.appendChild(button);

        tab.panel.id = `panel-${tab.id}`;
        tab.panel.classList.add('blockscape-tabpanel');
        tab.panel.setAttribute('role', 'tabpanel');
        tab.panel.setAttribute('aria-labelledby', button.id);
        tab.panel.hidden = idx === 0 ? false : true;
        if (idx === 0) tab.panel.classList.add('is-active');
        panelsWrapper.appendChild(tab.panel);
      });

      const activateTab = (targetId) => {
        tabDefs.forEach(t => {
          const isActive = t.id === targetId;
          t.button.classList.toggle('is-active', isActive);
          t.button.setAttribute('aria-selected', isActive ? 'true' : 'false');
          t.panel.classList.toggle('is-active', isActive);
          t.panel.hidden = !isActive;
        });
        handleTabVisibility(targetId);
      };

      tabDefs.forEach(t => {
        t.button.addEventListener('click', () => {
          hideTabTooltip();
          activateTab(t.id);
        });
        if (t.id === 'abstract') {
          t.button.addEventListener('mouseenter', () => showTabTooltip(t.button, infoTooltipHtml, { offset: 12 }));
          t.button.addEventListener('mouseleave', hideTabTooltip);
          t.button.addEventListener('focus', () => showTabTooltip(t.button, infoTooltipHtml, { offset: 12 }));
          t.button.addEventListener('blur', hideTabTooltip);
        }
      });

      activateTab(tabDefs[0].id);

      app.appendChild(tabsWrapper);

      const renderHost = document.createElement('div');
      renderHost.className = 'blockscape-render';
      mapPanel.appendChild(renderHost);

      const abstractWrapper = document.createElement('div');
      abstractWrapper.className = 'blockscape-abstract-panel';
      if (model.m.abstract) {
        console.log("[Blockscape] Rendering abstract content");
        const abstractDiv = document.createElement('div');
        abstractDiv.className = 'blockscape-abstract';
        abstractDiv.innerHTML = model.m.abstract;
        enhanceAbstractWithGistLinks(abstractDiv);
        abstractWrapper.appendChild(abstractDiv);
        infoTooltipHtml = abstractDiv.outerHTML;
      } else {
        console.log("[Blockscape] No abstract found in model.m");
        const placeholder = document.createElement('div');
        placeholder.className = 'blockscape-abstract-placeholder';
        placeholder.textContent = 'No abstract has been provided for this model.';
        abstractWrapper.appendChild(placeholder);
        infoTooltipHtml = placeholder.outerHTML;
      }
      abstractPanel.appendChild(abstractWrapper);

      const sourceWrapper = document.createElement('div');
      sourceWrapper.className = 'blockscape-source-panel';
      if (jsonPanel) {
        jsonPanel.hidden = false;
        jsonPanel.classList.remove('pf-v5-c-page__main-section');
        sourceWrapper.appendChild(jsonPanel);
      } else {
        const missing = document.createElement('p');
        missing.className = 'muted';
        missing.textContent = 'Source editor unavailable.';
        sourceWrapper.appendChild(missing);
      }
      sourcePanel.appendChild(sourceWrapper);
      mountApicurioTab(apicurioPanel);

      model.m.categories.forEach(cat => {
        const section = document.createElement('section');
        section.className = 'category';
        section.dataset.cat = cat.id;

        const head = document.createElement('div');
        head.className = 'cat-head';
        head.innerHTML = `<div class="cat-title">${escapeHtml(cat.title || cat.id)}</div>
                          <div class="muted cat-count">${(cat.items || []).length} items</div>`;
        section.appendChild(head);

        const grid = document.createElement('div');
        grid.className = 'grid';
        section.appendChild(grid);

        (cat.items || []).forEach(it => {
          const externalMeta = resolveExternalMeta(it.external);
          const tile = document.createElement('div');
          tile.className = externalMeta.isExternal ? 'tile external' : 'tile';
          tile.tabIndex = 0;
          tile.dataset.id = it.id;
          if (externalMeta.url) { tile.dataset.externalUrl = externalMeta.url; }

          const img = document.createElement('img');
          img.className = 'logo';
          if (it.logo) {
            img.src = it.logo; img.alt = it.name || it.id;
          } else {
            img.alt = "";
            img.style.opacity = 1; // colored letter icon is the intended visual
            img.src = generateLetterImage(it.name || it.id, it.color); // supports optional per-item color
          }

          const nm = document.createElement('div');
          nm.className = 'name';
          nm.textContent = it.name || it.id;

          const badge = document.createElement('div');
          badge.className = 'badge';
          badge.textContent = 'reused';

          if (externalMeta.url) {
            tile.appendChild(createExternalLinkButton(externalMeta.url));
          }
          tile.appendChild(img);
          tile.appendChild(nm);
          tile.appendChild(badge);
          grid.appendChild(tile);

          index.set(it.id, { el: tile, catId: cat.id, rect: null });
        });

        renderHost.appendChild(section);
      });

      model.reusedLocal.forEach(id => {
        const hit = index.get(id);
        if (hit) {
          hit.el.classList.add('reused');
          hit.el.querySelector('.badge').style.display = 'inline-block';
        }
      });

      wireEvents();
      reflowRects();
      drawLinks();
    }

    function wireEvents() {
      app.querySelectorAll('.tile').forEach(t => {
        t.addEventListener('click', (event) => {
          if (typeof event.button === 'number' && event.button !== 0) return;
          hidePreview();
          const id = t.dataset.id;
          console.log("[Blockscape] click", id);
          if (selection === id) { clearSelection(); return; }
          select(id);
        });
        t.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); t.click(); }
        });
        t.draggable = true;
        t.addEventListener('dragstart', handleDragStart);
        t.addEventListener('dragend', handleDragEnd);
      });

      app.querySelectorAll('.grid').forEach(grid => {
        grid.addEventListener('dragover', handleDragOver);
        grid.addEventListener('drop', handleDrop);
        grid.addEventListener('dragenter', handleDragEnter);
        grid.addEventListener('dragleave', handleDragLeave);
      });

      if (!globalEventsBound) {
        globalEventsBound = true;
        window.addEventListener('resize', scheduleOverlaySync);
        window.addEventListener('scroll', scheduleOverlaySync, { passive: true });
      }
      document.getElementById('clear').onclick = () => clearSelection();
    }

    function reflowRects() { index.forEach((v) => { v.rect = v.el.getBoundingClientRect(); }); }

    function select(id) {
      selection = id;
      clearStyles();
      const deps = Array.from(model.fwd.get(id) || []);
      const revs = Array.from(model.rev.get(id) || []);
      console.log("[Blockscape] selecting id=", id, "deps=", deps, "revs=", revs);
      const sel = index.get(id); if (sel) sel.el.classList.add('selected');
      deps.forEach(d => { const hit = index.get(d); if (hit) hit.el.classList.add('dep'); });
      revs.forEach(r => { const hit = index.get(r); if (hit) hit.el.classList.add('revdep'); });
      drawLinks();
    }

    function clearSelection() { selection = null; clearStyles(); drawLinks(); }
    function clearStyles() { app.querySelectorAll('.tile').forEach(t => t.classList.remove('dep', 'revdep', 'selected')); }

    function drawLinks() {
      while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
      if (!selection || overlay.hidden) return;

      const fromRect = index.get(selection)?.rect;
      if (!fromRect) return;

      const toList = new Set([...(model.fwd.get(selection) || []), ...(model.rev.get(selection) || [])]);
      toList.forEach(to => {
        const target = index.get(to);
        if (!target || !target.rect) return;
        const a = center(fromRect);
        const b = center(target.rect);
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const c1x = (a.x + b.x) / 2, c1y = a.y;
        const c2x = (a.x + b.x) / 2, c2y = b.y;
        const isDep = (model.fwd.get(selection) || new Set()).has(to);
        path.setAttribute("d", `M ${a.x},${a.y} C ${c1x},${c1y} ${c2x},${c2y} ${b.x},${b.y}`);
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", isDep ? "var(--blockscape-dep)" : "var(--blockscape-revdep)");
        path.setAttribute("stroke-opacity", "0.45");
        path.setAttribute("stroke-width", "2");
        path.setAttribute("vector-effect", "non-scaling-stroke");
        overlay.appendChild(path);
      });
    }

    function center(r) { return { x: r.left + r.width / 2, y: r.top + r.height / 2 }; }
    function escapeHtml(s) { return s.replace(/[&<>"']/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" }[m])); }

    function resolveExternalMeta(value) {
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) return { isExternal: false, url: '' };
        try {
          const url = new URL(trimmed);
          if (!/^https?:/i.test(url.protocol)) return { isExternal: false, url: '' };
          return { isExternal: true, url: url.toString() };
        } catch (error) {
          console.warn('[Blockscape] invalid external url skipped', value, error);
          return { isExternal: false, url: '' };
        }
      }
      if (value === true) {
        return { isExternal: true, url: '' };
      }
      return { isExternal: false, url: '' };
    }

    function createExternalLinkButton(url) {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'external-link';
      button.setAttribute('aria-label', 'Open external reference in a new tab');
      button.title = url;
      button.textContent = '↗';
      button.addEventListener('click', (event) => {
        event.stopPropagation();
        window.open(url, '_blank', 'noopener');
      });
      button.addEventListener('keydown', (event) => event.stopPropagation());
      return button;
    }

    function showTabTooltip(target, html, { offset = 8 } = {}) {
      if (!tabTooltip || !target || !html) return;
      tabTooltip.innerHTML = html;
      tabTooltip.hidden = false;
      tabTooltip.setAttribute('aria-hidden', 'false');
      requestAnimationFrame(() => {
        const rect = target.getBoundingClientRect();
        const tooltipRect = tabTooltip.getBoundingClientRect();
        const scrollX = window.scrollX || document.documentElement.scrollLeft;
        const scrollY = window.scrollY || document.documentElement.scrollTop;
        let left = rect.left + rect.width / 2 - tooltipRect.width / 2 + scrollX;
        let top = rect.top - tooltipRect.height - offset + scrollY;
        if (left < scrollX + offset) left = scrollX + offset;
        const maxLeft = scrollX + window.innerWidth - tooltipRect.width - offset;
        if (left > maxLeft) left = maxLeft;
        if (top < scrollY + offset) top = rect.bottom + offset + scrollY;
        tabTooltip.style.left = `${left}px`;
        tabTooltip.style.top = `${top}px`;
        tabTooltip.classList.add('is-visible');
      });
    }

    function hideTabTooltip() {
      if (!tabTooltip) return;
      tabTooltip.classList.remove('is-visible');
      tabTooltip.setAttribute('aria-hidden', 'true');
      tabTooltip.hidden = true;
    }

    window.addEventListener('scroll', hideTabTooltip, true);
    window.addEventListener('resize', hideTabTooltip);

    function hidePreview() {
      if (!preview) return;
      preview.classList.remove('is-visible', 'item-preview--has-frame', 'item-preview--expanded');
      preview.setAttribute('aria-hidden', 'true');
      preview.hidden = true;
      setPreviewActions('');
    }

    function showPreviewAt(x, y) {
      if (!preview) return;
      previewAnchor = { x, y };
      preview.hidden = false;
      preview.setAttribute('aria-hidden', 'false');
      preview.classList.add('is-visible');
      positionPreview(x, y);
    }

    function positionPreview(x, y) {
      if (!preview) return;
      const margin = 12;
      preview.style.left = `${x + margin}px`;
      preview.style.top = `${y + margin}px`;
      const rect = preview.getBoundingClientRect();
      let left = rect.left;
      let top = rect.top;
      if (rect.right > window.innerWidth - margin) {
        left = Math.max(margin, window.innerWidth - rect.width - margin);
      }
      if (rect.bottom > window.innerHeight - margin) {
        top = Math.max(margin, window.innerHeight - rect.height - margin);
      }
      preview.style.left = `${left}px`;
      preview.style.top = `${top}px`;
    }

    function setPreviewActions(url) {
      if (!previewActions) return;
      previewActions.innerHTML = '';
      if (url) {
        const action = document.createElement('button');
        action.type = 'button';
        action.className = 'item-preview__action';
        action.innerHTML = 'Open external link <span aria-hidden="true">↗</span>';
        action.title = url;
        action.addEventListener('click', (event) => {
          event.stopPropagation();
          window.open(url, '_blank', 'noopener');
        });
        previewActions.appendChild(action);
        previewActions.hidden = false;
      } else {
        previewActions.hidden = true;
      }
    }

    async function handleTileContextMenu(event, tile) {
      if (!preview) return;
      event.stopPropagation();
      event.preventDefault();
      const id = tile.dataset.id;
      const displayName = tile.querySelector('.name')?.textContent || id || 'Preview';
      const filename = id ? `${id}.html` : '';
      const filepath = filename ? `items/${filename}` : '';
      const requestId = ++previewRequestId;
      const externalUrl = tile.dataset.externalUrl || '';
      setPreviewActions(externalUrl);

      previewTitle.textContent = displayName;
      previewBody.innerHTML = '<div class="item-preview__status">Loading…</div>';
      preview.classList.remove('item-preview--has-frame');
      preview.classList.add('item-preview--expanded');
      showPreviewAt(event.clientX, event.clientY);

      if (!filepath) {
        previewBody.innerHTML = '<div class="item-preview__status">Preview unavailable for this item.</div>';
        positionPreview(previewAnchor.x, previewAnchor.y);
        return;
      }

      try {
        const response = await fetch(filepath, { cache: 'no-cache' });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const html = await response.text();
        if (requestId !== previewRequestId) return;
        const trimmed = html.trim();
        if (!trimmed) {
          previewBody.innerHTML = `<div class="item-preview__status">No content in <code>${escapeHtml(filename)}</code>.</div>`;
          positionPreview(previewAnchor.x, previewAnchor.y);
          return;
        }
        const frame = document.createElement('iframe');
        frame.className = 'item-preview__frame';
        frame.title = `${displayName} details`;
        frame.srcdoc = html;
        previewBody.innerHTML = '';
        previewBody.appendChild(frame);
        preview.classList.add('item-preview--has-frame');
        positionPreview(previewAnchor.x, previewAnchor.y);
      } catch (error) {
        if (requestId !== previewRequestId) return;
        previewBody.innerHTML = `<div class="item-preview__status">No preview available for <strong>${escapeHtml(displayName)}</strong>.</div>`;
        console.warn(`[Blockscape] preview unavailable for ${filepath}`, error);
        positionPreview(previewAnchor.x, previewAnchor.y);
      }
    }

    if (previewClose) {
      previewClose.addEventListener('click', hidePreview);
    }

    if (app) {
      app.addEventListener('contextmenu', (event) => {
        const tile = event.target.closest('.tile');
        if (!tile || !app.contains(tile)) return;
        handleTileContextMenu(event, tile);
      });
    }

    document.addEventListener('click', (event) => {
      if (typeof event.button === 'number' && event.button !== 0) return;
      if (!preview || preview.hidden) return;
      if (preview.contains(event.target)) return;
      hidePreview();
    });

    if (downloadButton) {
      downloadButton.addEventListener('click', () => {
        downloadCurrentJson('button');
      });
    }

    if (shareButton) {
      shareButton.addEventListener('click', async () => {
        if (activeIndex < 0 || !models[activeIndex]) {
          alert('Select or load a model before sharing.');
          return;
        }
        const payload = {
          title: getModelTitle(models[activeIndex], 'Shared Model'),
          data: models[activeIndex].data
        };
        let encoded;
        try {
          encoded = base64UrlEncode(JSON.stringify(payload));
        } catch (err) {
          console.error('[Blockscape] share encode failed', err);
          alert('Unable to encode this model for sharing.');
          return;
        }
        const shareUrl = new URL(window.location.href);
        shareUrl.searchParams.delete('share');
        shareUrl.hash = `share=${encoded}`;
        const fullUrl = shareUrl.toString();

        // Update the address bar so the current page URL matches the share URL
        try {
          window.history.replaceState({}, document.title, fullUrl);
        } catch (err) {
          console.warn('[Blockscape] failed to update URL for share', err);
          window.location.hash = shareUrl.hash;
        }

        let copied = false;
        if (navigator.clipboard?.writeText) {
          try {
            await navigator.clipboard.writeText(fullUrl);
            copied = true;
          } catch (err) {
            console.warn('[Blockscape] clipboard write failed', err);
          }
        }
        if (copied) {
          alert('Share URL copied to clipboard.');
        } else {
          window.prompt('Copy this share URL:', fullUrl);
        }
      });
    }

    if (editButton) {
      editButton.addEventListener('click', () => {
        const text = (jsonBox.value || '').trim();
        if (!text) {
          alert('Load or paste a model before opening the editor.');
          return;
        }
        try {
          JSON.parse(text);
        } catch (err) {
          alert('Current JSON is invalid. Fix it before opening the editor.');
          return;
        }
        try {
          const payload = {
            ts: Date.now(),
            text,
            source: 'viewer'
          };
          if (selection) {
            payload.selectedItemId = selection;
          }
          localStorage.setItem(EDITOR_TRANSFER_KEY, JSON.stringify(payload));
        } catch (storageError) {
          console.error('[Blockscape] failed to store editor payload', storageError);
          alert('Unable to stash JSON for the editor (storage disabled?).');
          return;
        }
        let editorUrl = 'editor.html#viewer';
        if (selection) {
          const encoded = encodeURIComponent(selection);
          editorUrl = `editor.html?selected=${encoded}#viewer`;
        }
        window.open(editorUrl, '_blank');
      });
    }

    if (typeof window !== 'undefined') {
      window.addEventListener('storage', (event) => {
        if (!event) return;
        if (event.storageArea && event.storageArea !== window.localStorage) return;
        if (event.key !== EDITOR_TRANSFER_KEY) return;
        if (!event.newValue) return;
        let payload;
        try {
          payload = JSON.parse(event.newValue);
        } catch (err) {
          console.warn('[Blockscape] storage payload parse failed', err);
          return;
        }
        if (!payload || payload.source !== 'editor') return;
        importEditorPayload('storage-event');
      });

      window.addEventListener('message', (event) => {
        if (!event || !event.data) return;
        const currentOrigin = window.location.origin;
        if (currentOrigin && currentOrigin !== 'null') {
          if (event.origin !== currentOrigin) return;
        } else if (event.origin && event.origin !== 'null') {
          return;
        }
        if (typeof event.data !== 'object') return;
        if (event.data === null) return;
        if (event.data.type !== EDITOR_TRANSFER_MESSAGE_TYPE) return;
        importEditorPayload('message');
      });
    }

    document.addEventListener('keydown', (event) => {
      if ((event.ctrlKey || event.metaKey) && event.code === 'KeyS') {
        event.preventDefault();
        downloadCurrentJson('shortcut');
        return;
      }

      if ((event.ctrlKey || event.metaKey) && !event.altKey && !event.shiftKey && event.key && event.key.toLowerCase() === 'z') {
        if (!shouldHandleGlobalPaste()) return;
        const undone = undoLastDeletion();
        if (undone) {
          event.preventDefault();
          return;
        }
      }

      if (event.key === 'Escape' && preview && !preview.hidden) {
        hidePreview();
      }

      if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
        if (!shouldHandleGlobalPaste()) return;
        if (event.altKey || event.ctrlKey || event.metaKey) return;
        const step = event.key === 'ArrowLeft' ? -1 : 1;
        if (event.shiftKey) {
          const moved = moveSelectionWithinCategory(step);
          if (moved) {
            event.preventDefault();
          }
        } else {
          const changed = selectAdjacentItem(step);
          if (changed) {
            event.preventDefault();
          }
        }
      }

      if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
        if (!shouldHandleGlobalPaste()) return;
        if (event.altKey || event.ctrlKey || event.metaKey) return;
        const step = event.key === 'ArrowUp' ? -1 : 1;
        if (event.shiftKey) {
          const moved = moveSelectionAcrossCategories(step);
          if (moved) {
            event.preventDefault();
          }
        } else {
          const moved = selectAdjacentCategory(step);
          if (moved) {
            event.preventDefault();
          }
        }
      }

      if (event.key === 'Delete') {
        if (!shouldHandleGlobalPaste()) return;
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) return;
        const removed = deleteSelectedItem();
        if (removed) {
          event.preventDefault();
        }
      }
    });

    window.addEventListener('resize', () => {
      if (!preview || preview.hidden) return;
      positionPreview(previewAnchor.x, previewAnchor.y);
    });

    window.addEventListener('scroll', () => {
      if (!preview || preview.hidden) return;
      hidePreview();
    }, true);

    // ===== Drag and drop reorder (per model) =====
    let draggedItemId = null;
    let draggedCategoryId = null;

    function handleDragStart(e) {
      hidePreview();
      draggedItemId = e.target.dataset.id;
      draggedCategoryId = e.target.closest('.category').dataset.cat;

      e.target.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', JSON.stringify({
        itemId: draggedItemId,
        categoryId: draggedCategoryId
      }));

      const category = e.target.closest('.category');
      const grid = category.querySelector('.grid');
      grid.classList.add('drag-active');

      console.log("[Blockscape] drag start", draggedItemId, "from", draggedCategoryId);
    }

    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
      app.querySelectorAll('.grid').forEach(grid => grid.classList.remove('drag-active'));
      app.querySelectorAll('.tile').forEach(tile => tile.classList.remove('drag-over'));
      draggedItemId = null;
      draggedCategoryId = null;
    }

    function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }
    function handleDragEnter(e) {
      e.preventDefault();
      const grid = e.target.closest('.grid');
      if (grid) grid.classList.add('drag-active');
    }
    function handleDragLeave(e) {
      const grid = e.target.closest('.grid');
      if (grid && !grid.contains(e.relatedTarget)) grid.classList.remove('drag-active');
    }

    function handleDrop(e) {
      e.preventDefault();
      const targetGrid = e.target.closest('.grid');
      if (!targetGrid) return;
      const targetCategory = targetGrid.closest('.category');
      if (!targetCategory) return;
      const targetCategoryId = targetCategory.dataset.cat;

      if (!draggedItemId || !targetCategoryId) return;

      const tiles = Array.from(targetGrid.querySelectorAll('.tile')).filter(tile => tile.dataset.id !== draggedItemId);
      const targetTile = tiles.find(tile => {
        const rect = tile.getBoundingClientRect();
        return e.clientY < rect.top + rect.height / 2;
      });

      reorderItem(draggedItemId, targetTile ? targetTile.dataset.id : null, targetCategoryId);
      render();
      console.log("[Blockscape] drop completed", draggedItemId, "from", draggedCategoryId, "to", targetCategoryId);
    }

    function reorderItem(itemId, targetItemId, targetCategoryId) {
      if (activeIndex < 0) return;
      const mobj = models[activeIndex].data;
      const categories = mobj.categories || [];
      const sourceCategory = categories.find(cat => (cat.items || []).some(item => item.id === itemId));
      const targetCategory = categories.find(cat => cat.id === targetCategoryId);
      if (!sourceCategory || !targetCategory) return;

      sourceCategory.items = sourceCategory.items || [];
      targetCategory.items = targetCategory.items || [];

      const itemIndex = sourceCategory.items.findIndex(item => item.id === itemId);
      if (itemIndex === -1) return;

      const [movedItem] = sourceCategory.items.splice(itemIndex, 1);
      let insertIndex = targetCategory.items.length;
      if (targetItemId) {
        const targetIndex = targetCategory.items.findIndex(item => item.id === targetItemId);
        if (targetIndex !== -1) insertIndex = targetIndex;
      }
      targetCategory.items.splice(insertIndex, 0, movedItem);

      // keep editor in sync
      loadActiveIntoEditor();
      rebuildFromActive();
    }

    function moveSelectionWithinCategory(step) {
      if (!selection || activeIndex < 0 || !step) return false;
      const mobj = models[activeIndex].data;
      const categories = mobj.categories || [];
      const selectedMeta = index.get(selection);
      let category = null;
      if (selectedMeta?.catId) {
        category = categories.find(cat => cat.id === selectedMeta.catId);
      }
      if (!category) {
        category = categories.find(cat => (cat.items || []).some(item => item.id === selection));
      }
      if (!category) return false;

      category.items = category.items || [];
      const currentIndex = category.items.findIndex(item => item.id === selection);
      if (currentIndex === -1) return false;

      const targetIndex = currentIndex + step;
      if (targetIndex < 0 || targetIndex >= category.items.length) return false;

      const [movedItem] = category.items.splice(currentIndex, 1);
      category.items.splice(targetIndex, 0, movedItem);

      loadActiveIntoEditor();
      rebuildFromActive();
      render();
      select(selection);
      return true;
    }

    function selectAdjacentItem(step) {
      if (!model || !model.m || !step) return false;
      const categories = model.m.categories || [];
      if (!categories.length) return false;

      const findFirstItem = () => {
        const firstCategory = categories.find(cat => (cat.items || []).length);
        if (!firstCategory) return null;
        return { category: firstCategory, item: firstCategory.items[0] };
      };

      if (!selection) {
        const starter = findFirstItem();
        if (!starter) return false;
        select(starter.item.id);
        return true;
      }

      const selectedMeta = index.get(selection);
      let category = null;
      if (selectedMeta?.catId) {
        category = categories.find(cat => cat.id === selectedMeta.catId);
      }
      if (!category) {
        category = categories.find(cat => (cat.items || []).some(item => item.id === selection));
      }
      if (!category) {
        const starter = findFirstItem();
        if (!starter) return false;
        select(starter.item.id);
        return true;
      }

      const items = category.items || [];
      if (!items.length) return false;
      const currentIndex = items.findIndex(item => item.id === selection);
      if (currentIndex === -1) return false;

      const targetIndex = currentIndex + step;
      if (targetIndex < 0 || targetIndex >= items.length) return false;

      select(items[targetIndex].id);
      return true;
    }

    function selectAdjacentCategory(step) {
      if (!model || !model.m || !step) return false;
      const categories = model.m.categories || [];
      if (!categories.length) return false;

      const getFirstSelectable = () => {
        for (const cat of categories) {
          if (cat.items && cat.items.length) {
            return cat.items[0].id;
          }
        }
        return null;
      };

      const resolveCategoryIndexForSelection = () => {
        if (!selection) return -1;
        const selectedMeta = index.get(selection);
        if (selectedMeta?.catId) {
          const idx = categories.findIndex(cat => cat.id === selectedMeta.catId);
          if (idx !== -1) return idx;
        }
        return categories.findIndex(cat => (cat.items || []).some(item => item.id === selection));
      };

      let currentCategoryIndex = resolveCategoryIndexForSelection();
      if (currentCategoryIndex === -1) {
        const first = getFirstSelectable();
        if (!first) return false;
        select(first);
        return true;
      }

      const currentItems = categories[currentCategoryIndex].items || [];
      let currentItemPosition = currentItems.findIndex(item => item.id === selection);
      if (currentItemPosition === -1) currentItemPosition = 0;

      let targetIndex = currentCategoryIndex + step;
      while (targetIndex >= 0 && targetIndex < categories.length) {
        const targetCat = categories[targetIndex];
        const items = targetCat.items || [];
        if (items.length) {
          const pos = Math.min(items.length - 1, Math.max(0, currentItemPosition));
          select(items[pos].id);
          return true;
        }
        targetIndex += step > 0 ? 1 : -1;
      }

      return false;
    }

    function moveSelectionAcrossCategories(step) {
      if (!selection || activeIndex < 0 || !step) return false;
      const mobj = models[activeIndex].data;
      const categories = mobj.categories || [];
      if (!categories.length) return false;

      const selectedMeta = index.get(selection);
      let sourceIndex = -1;
      if (selectedMeta?.catId) {
        sourceIndex = categories.findIndex(cat => cat.id === selectedMeta.catId);
      }
      if (sourceIndex === -1) {
        sourceIndex = categories.findIndex(cat => (cat.items || []).some(item => item.id === selection));
      }
      if (sourceIndex === -1) return false;

      const targetIndex = sourceIndex + step;
      if (targetIndex < 0 || targetIndex >= categories.length) return false;

      const sourceCategory = categories[sourceIndex];
      const targetCategory = categories[targetIndex];
      if (!targetCategory) return false;

      sourceCategory.items = sourceCategory.items || [];
      targetCategory.items = targetCategory.items || [];

      const currentIndex = sourceCategory.items.findIndex(item => item.id === selection);
      if (currentIndex === -1) return false;

      const insertPos = Math.min(targetCategory.items.length, Math.max(0, currentIndex));
      const targetItemId = insertPos < targetCategory.items.length ? targetCategory.items[insertPos].id : null;

      reorderItem(selection, targetItemId, targetCategory.id);
      render();
      select(selection);
      return true;
    }

    function undoLastDeletion() {
      if (!lastDeletedItem || activeIndex < 0) return false;
      const activeModel = models[activeIndex];
      if (!activeModel || activeModel.id !== lastDeletedItem.modelId) return false;

      const deleted = lastDeletedItem;
      const mobj = activeModel.data;
      const categories = mobj.categories || [];
      const category = categories.find(cat => cat.id === deleted.categoryId);
      if (!category) return false;

      category.items = category.items || [];
      const insertIndex = Math.min(Math.max(deleted.index, 0), category.items.length);
      category.items.splice(insertIndex, 0, deleted.item);

      lastDeletedItem = null;
      hidePreview();
      selection = null;
      loadActiveIntoEditor();
      rebuildFromActive();
      render();
      select(deleted.item.id);
      console.log("[Blockscape] undo delete restored", deleted.item.id);
      return true;
    }

    function deleteSelectedItem() {
      if (!selection || activeIndex < 0) return false;
      const mobj = models[activeIndex].data;
      const categories = mobj.categories || [];
      if (!categories.length) return false;

      const selectedMeta = index.get(selection);
      let category = null;
      if (selectedMeta?.catId) {
        category = categories.find(cat => cat.id === selectedMeta.catId);
      }
      if (!category) {
        category = categories.find(cat => (cat.items || []).some(item => item.id === selection));
      }
      if (!category || !Array.isArray(category.items)) return false;

      const currentIndex = category.items.findIndex(item => item.id === selection);
      if (currentIndex === -1) return false;

      const removed = category.items.splice(currentIndex, 1)[0];
      if (!removed) return false;

      const activeModel = models[activeIndex];
      lastDeletedItem = {
        item: removed,
        categoryId: category.id,
        index: currentIndex,
        modelId: activeModel ? activeModel.id : null
      };

      const findNextSelection = () => {
        if (category.items.length) {
          const neighborIndex = Math.min(currentIndex, category.items.length - 1);
          return category.items[neighborIndex]?.id || null;
        }
        const catIndex = categories.findIndex(cat => cat.id === category.id);
        if (catIndex === -1) return null;
        for (let i = catIndex + 1; i < categories.length; i++) {
          const items = categories[i].items || [];
          if (items.length) return items[0].id;
        }
        for (let i = catIndex - 1; i >= 0; i--) {
          const items = categories[i].items || [];
          if (items.length) return items[0].id;
        }
        return null;
      };

      const nextSelectionId = findNextSelection();
      hidePreview();
      selection = null;
      loadActiveIntoEditor();
      rebuildFromActive();
      render();
      if (nextSelectionId) {
        select(nextSelectionId);
      } else {
        clearSelection();
      }
      console.log("[Blockscape] removed item", removed.id);
      return true;
    }

    // ===== Controls =====

    if (copyJsonButton) {
      copyJsonButton.addEventListener('click', async () => {
        const text = jsonBox.value || '';
        if (!text.trim()) {
          alert('JSON editor is empty.');
          return;
        }
        const copied = await writeTextToClipboard(text);
        if (copied) {
          alert('JSON copied to clipboard.');
        } else {
          window.prompt('Copy this JSON manually:', text);
        }
      });
    }

    if (pasteJsonButton) {
      pasteJsonButton.addEventListener('click', async () => {
        try {
          const text = await readTextFromClipboard();
          if (!text) {
            alert('Clipboard is empty.');
            return;
          }
          jsonBox.value = text;
          jsonBox.focus();
        } catch (err) {
          console.warn('[Blockscape] clipboard read failed', err);
          alert('Unable to read from the clipboard. Use Cmd/Ctrl+V inside the editor instead.');
        }
      });
    }

    // Append models from textarea
    document.getElementById('appendFromBox').onclick = () => {
      try {
        const appended = normalizeToModelsFromText(jsonBox.value, "Pasted");
        if (!appended.length) { alert("No valid JSON found to append."); return; }
        console.log("[Blockscape] appending", appended.length, "model(s)");
        models.push(...appended);
        if (activeIndex === -1) setActive(0); else { renderModelList(); }
      } catch (e) {
        console.error("[Blockscape] append error:", e);
        alert("Append error (see console).");
      }
    };

    // Replace active model data with JSON from textarea
    document.getElementById('replaceActive').onclick = () => {
      if (activeIndex < 0) { alert("No active model selected."); return; }
      try {
        const obj = JSON.parse(jsonBox.value);
        ensureModelMetadata(obj, { 
          titleHint: getModelTitle(models[activeIndex]), 
          idHint: getModelId(models[activeIndex]) || getModelTitle(models[activeIndex]) 
        });
        models[activeIndex].data = obj;
        models[activeIndex].title = obj.title || models[activeIndex].title;
        syncDocumentTitle();
        console.log("[Blockscape] replaced active model:", getModelTitle(models[activeIndex]));
        rebuildFromActive();
        updateApicurioAvailability();
      } catch (e) {
        console.error("[Blockscape] replace error:", e);
        alert("JSON parse error (see console).");
      }
    };

    // Load files: each text may be single object, array, or ---/%%% separated
    document.getElementById('file').onchange = async (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;
      try {
        console.log("[Blockscape] reading", files.length, "file(s)");
        for (const f of files) {
          const txt = await f.text();
          const entries = normalizeToModelsFromText(txt, f.name.replace(/\.[^.]+$/, '') || "File");
          if (!entries.length) {
            console.warn("[Blockscape] no models in file:", f.name);
            continue;
          }
          // Ensure file-derived entries prefer embedded title/id but fall back to filename
          models.push(...entries.map((en, i) => {
            const dataTitle = (en.data?.title ?? '').toString().trim();
            const fallbackTitle = entries.length > 1 ? `${f.name} #${i + 1}` : f.name;
            return { ...en, title: dataTitle || fallbackTitle };
          }));
        }
        if (activeIndex === -1 && models.length) setActive(0);
        else renderModelList();
      } catch (err) {
        console.error("[Blockscape] file load error:", err);
        alert("File load error (see console).");
      } finally {
        e.target.value = ""; // allow re-selecting the same files
      }
    };

    // Paste JSON anywhere to append new models
    document.addEventListener('paste', handleClipboardPaste);

    function handleClipboardPaste(event) {
      if (!shouldHandleGlobalPaste()) return;
      const text = event.clipboardData?.getData('text/plain')
        || (window.clipboardData && window.clipboardData.getData('Text'))
        || '';
      if (!looksLikeModelJson(text)) return;
      let entries = [];
      try {
        entries = normalizeToModelsFromText(text, 'Clipboard');
      } catch (err) {
        console.warn('[Blockscape] clipboard paste ignored (invalid JSON)', err);
        return;
      }
      if (!entries.length) return;
      event.preventDefault();
      const startIndex = models.length;
      models.push(...entries);
      console.log(`[Blockscape] pasted ${entries.length} model(s) from clipboard`);
      setActive(startIndex);
    }

    // Switch active model from sidebar
    modelList.addEventListener('click', (e) => {
      const button = e.target.closest('button[data-index]');
      if (!button) return;
      const i = parseInt(button.dataset.index, 10);
      if (!Number.isInteger(i)) return;
      scrollPageToTop();
      setActive(i);
    });

    // Remove selected model
    document.getElementById('removeModel').onclick = () => {
      if (activeIndex < 0) return;
      console.log("[Blockscape] removing model:", getModelTitle(models[activeIndex]));
      models.splice(activeIndex, 1);
      if (!models.length) {
        activeIndex = -1;
        model = null;
        app.innerHTML = "";
        overlay.innerHTML = "";
        jsonBox.value = "";
        renderModelList();
        syncDocumentTitle();
        return;
      }
      const next = Math.min(activeIndex, models.length - 1);
      setActive(next);
    };

    // Search filter
    document.getElementById('search').addEventListener('input', (e) => {
      const q = e.target.value.trim().toLowerCase();
      console.log("[Blockscape] search:", q);
      app.querySelectorAll('.tile').forEach(t => {
        const name = t.querySelector('.name').textContent.toLowerCase();
        t.style.opacity = (!q || name.includes(q)) ? 1 : .2;
      });
    });

    // Load from URL
    if (urlForm && urlInput && loadUrlButton) {
      urlForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const url = urlInput.value.trim();
        if (!url) {
          alert("Please enter a URL");
          urlInput.focus();
          return;
        }
        const ok = await loadFromUrl(url);
        if (ok) {
          urlInput.value = '';
          const hint = document.getElementById('urlHint');
          if (hint) hint.textContent = '';
        }
      });
    }

    // Show last 12 characters after user pauses typing
    (function attachUrlHint() {
      const hint = document.getElementById('urlHint');
      if (!urlInput || !hint) return;
      let timer = null;
      urlInput.addEventListener('input', () => {
        clearTimeout(timer);
        timer = setTimeout(() => {
          const value = urlInput.value;
          const tail = value.slice(-12);
          hint.textContent = tail ? `…${tail}` : '';
        }, 300);
      });
    })();

    // Helpers
    function rebuildFromActive() {
      if (activeIndex < 0) return;
      try {
        const parsed = parse(models[activeIndex].data);
        model = parsed;
        render();
      } catch (e) {
        console.error("[Blockscape] rebuild error (active model likely malformed):", e);
        alert("Active model parse/render error (see console).");
      }
    }

    // Load JSON files from same directory (for static hosting)
    async function loadJsonFiles() {
      const jsonFiles = ['APIs.bs','wardley.bs'];
      
      for (const filename of jsonFiles) {
        try {
          const response = await fetch(filename, { cache: 'no-store' });
          if (!response.ok) continue;

          const text = await response.text();
          const baseName = filename.replace(/\.[^.]+$/, '') || 'Model';
          const entries = normalizeToModelsFromText(text, baseName);
          if (!entries.length) {
            console.warn("[Blockscape] no models found in", filename);
            continue;
          }

          models.push(...entries);
          console.log(`[Blockscape] loaded ${entries.length} model(s) from ${filename}`);
        } catch (error) {
          console.log("[Blockscape] could not load", filename, "- this is normal for file:// protocol");
        }
      }
    }

    async function fetchTextWithCacheBypass(url) {
      const attempts = [
        { cache: 'no-store' },
        { cache: 'reload' },
        {}
      ];
      let lastError = null;
      for (const opts of attempts) {
        try {
          console.log(`[Blockscape] fetching ${url} with cache="${opts.cache ?? 'default'}"`);
          const response = await fetch(url, opts);
          if (response.status === 304) {
            console.warn("[Blockscape] fetch returned 304 (Not Modified), retrying without cache");
            continue;
          }
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          return await response.text();
        } catch (error) {
          lastError = error;
        }
      }
      throw lastError || new Error('Unable to fetch URL');
    }

    function enhanceAbstractWithGistLinks(container) {
      if (!container) return;

      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
      const textNodes = [];
      while (walker.nextNode()) {
        textNodes.push(walker.currentNode);
      }

      textNodes.forEach(node => convertTextNodeGistLinks(node));

      container.querySelectorAll('a[href]').forEach(anchor => {
        const href = anchor.getAttribute('href');
        if (isGistUrl(href)) {
          attachGistLinkBehavior(anchor, href);
        }
      });
    }

    function convertTextNodeGistLinks(node) {
      if (!node || !node.nodeValue || !node.nodeValue.includes('http')) return;
      const text = node.nodeValue;
      const regex = /(https?:\/\/[^\s<]+)/gi;
      const matches = [];
      let match;
      while ((match = regex.exec(text)) !== null) {
        if (isGistUrl(match[0])) {
          matches.push({ url: match[0], index: match.index });
        }
      }
      if (!matches.length) return;

      const fragment = document.createDocumentFragment();
      let cursor = 0;
      matches.forEach(({ url, index }) => {
        if (index > cursor) {
          fragment.appendChild(document.createTextNode(text.slice(cursor, index)));
        }
        fragment.appendChild(createGistLinkAnchor(url));
        cursor = index + url.length;
      });
      if (cursor < text.length) {
        fragment.appendChild(document.createTextNode(text.slice(cursor)));
      }
      node.parentNode.replaceChild(fragment, node);
    }

    function createGistLinkAnchor(url) {
      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.textContent = url;
      anchor.target = '_blank';
      anchor.rel = 'noopener noreferrer';
      attachGistLinkBehavior(anchor, url);
      return anchor;
    }

    function attachGistLinkBehavior(anchor, url) {
      if (!anchor || anchor.dataset.gistLinkBound === 'true') return;
      anchor.dataset.gistLinkBound = 'true';
      anchor.classList.add('blockscape-gist-link');
      anchor.title = 'Load this Gist into Blockscape';
      anchor.addEventListener('click', (event) => handleGistLinkClick(event, url, anchor));
    }

    async function handleGistLinkClick(event, url, anchor) {
      event.preventDefault();
      event.stopPropagation();
      if (!url || anchor.dataset.loading === 'true') return;
      anchor.dataset.loading = 'true';
      anchor.classList.add('is-loading');
      try {
        await loadFromUrl(url);
      } finally {
        anchor.dataset.loading = 'false';
        anchor.classList.remove('is-loading');
      }
    }

    function isGistUrl(candidate) {
      if (typeof candidate !== 'string') return false;
      try {
        const parsed = new URL(candidate, window.location.href);
        const host = parsed.hostname.toLowerCase();
        return host === 'gist.githubusercontent.com'
          || (host.startsWith('gist.') && host.endsWith('githubusercontent.com'));
      } catch {
        return false;
      }
    }

    // Load JSON from custom URL
    async function loadFromUrl(url) {
      try {
        console.log("[Blockscape] loading from URL:", url);
        const text = await fetchTextWithCacheBypass(url);
        const rawName = url.split('/').pop() || '';
        const baseName = rawName.replace(/\.[^.]+$/, '') || 'URL Model';
        let entries;
        try {
          entries = normalizeToModelsFromText(text, baseName);
        } catch (parseError) {
          throw new Error(`Invalid JSON payload: ${parseError.message}`);
        }
        if (!entries.length) {
          throw new Error('No JSON objects found in response.');
        }
        models.push(...entries.map((entry, idx) => {
          const dataTitle = (entry.data?.title ?? '').toString().trim();
          const fallbackTitle = entries.length > 1 ? `${baseName} #${idx + 1}` : baseName;
          return {
            ...entry,
            title: dataTitle || fallbackTitle
          };
        }));
        console.log(`[Blockscape] loaded ${entries.length} model(s) from URL:`, baseName);
        if (activeIndex === -1) {
          setActive(0);
        } else {
          renderModelList();
        }
        return true;
      } catch (error) {
        console.error("[Blockscape] URL load error:", error);
        alert(`Failed to load JSON from URL: ${error.message}`);
        return false;
      }
    }

    // Bootstrap with Blockscape
    (async function bootstrap() {
      const seedObj = JSON.parse(document.getElementById('seed').innerHTML.trim());
      ensureModelMetadata(seedObj, { titleHint: seedObj.title || 'Blockscape', idHint: seedObj.id || 'blockscape' });
      
      models.push({ id: uid(), title: seedObj.title || "Blockscape", data: seedObj });
      
      // Try to load JSON files from same directory
      await loadJsonFiles();
      
      // Load explicit model from URL hash/search (?load= or #load=)
      const loadIndex = await consumeLoadParam();
      const editorIndex = consumeEditorPayload();
      const shareIndex = consumeShareLink();
      const initialIndex = typeof loadIndex === 'number'
        ? loadIndex
        : (typeof shareIndex === 'number'
          ? shareIndex
          : (typeof editorIndex === 'number' ? editorIndex : 0));
      setActive(initialIndex);
    })();
  </script>
</body>

</html>
